---
globs: "src/algorithms/forgetting-algorithm.ts,src/services/forgetting-policy-service.ts"
description: ë§ê° ì•Œê³ ë¦¬ì¦˜ ë° ë§ê° ì •ì±… ì„œë¹„ìŠ¤ ê°œë°œ ê·œì¹™
---

# ë§ê° ì•Œê³ ë¦¬ì¦˜ ë° ë§ê° ì •ì±… ì„œë¹„ìŠ¤ ê·œì¹™

## ğŸ“‹ ë§ê° ì•Œê³ ë¦¬ì¦˜

### í˜„ì¬ êµ¬í˜„ ìƒíƒœ
- **íŒŒì¼**: `src/algorithms/forgetting-algorithm.ts` (244ì¤„)
- **ê¸°ëŠ¥**: Memento-Goals.mdì˜ ë§ê° ê³µì‹ êµ¬í˜„
- **íŠ¹ì§•**: ìµœê·¼ì„±, ì‚¬ìš©ì„±, ì¤‘ë³µ ë¹„ìœ¨, ì¤‘ìš”ë„, ê³ ì • ì—¬ë¶€ë¥¼ ì¢…í•©í•œ ë§ê° ì ìˆ˜ ê³„ì‚°

### í•µì‹¬ ì¸í„°í˜ì´ìŠ¤

```typescript
interface ForgettingFeatures {
  recency: number;        // ìµœê·¼ì„± (0-1)
  usage: number;          // ì‚¬ìš©ì„± (0-1)
  duplication_ratio: number; // ì¤‘ë³µ ë¹„ìœ¨ (0-1)
  importance: number;     // ì¤‘ìš”ë„ (0-1)
  pinned: boolean;        // ê³ ì • ì—¬ë¶€
}

interface ForgettingWeights {
  recency: number;        // U1 = 0.35
  usage: number;          // U2 = 0.25
  duplication: number;    // U3 = 0.20
  importance: number;     // U4 = 0.15
  pinned: number;         // U5 = 0.30
}

interface ForgettingResult {
  memory_id: string;
  forget_score: number;
  should_forget: boolean;
  reason: string;
  features: ForgettingFeatures;
}
```

### êµ¬í˜„ ê°€ì´ë“œë¼ì¸

#### 1. ë§ê° ì ìˆ˜ ê³„ì‚°
```typescript
calculateForgetScore(features: ForgettingFeatures): number {
  const { recency, usage, duplication_ratio, importance, pinned } = features;
  
  // ë§ê° ì ìˆ˜ ê³µì‹: U1*(1-recency) + U2*(1-usage) + U3*duplication - U4*importance - U5*pinned
  const score = 
    this.weights.recency * (1 - recency) +
    this.weights.usage * (1 - usage) +
    this.weights.duplication * duplication_ratio -
    this.weights.importance * importance -
    this.weights.pinned * (pinned ? 1 : 0);
  
  return Math.max(0, Math.min(1, score));
}
```

#### 2. íŠ¹ì§• ê³„ì‚°
```typescript
// ìµœê·¼ì„± ê³„ì‚° (ì§€ìˆ˜ ê°ì‡ )
calculateRecency(createdAt: Date, type: string): number {
  const ageDays = this.getAgeInDays(createdAt);
  const halfLife = this.getHalfLife(type);
  return Math.exp(-Math.log(2) * ageDays / halfLife);
}

// ì‚¬ìš©ì„± ê³„ì‚° (ë¡œê·¸ ìŠ¤ì¼€ì¼)
calculateUsage(viewCount: number, citeCount: number, editCount: number): number {
  const rawUsage = 
    Math.log(1 + viewCount) +
    2 * Math.log(1 + citeCount) +
    0.5 * Math.log(1 + editCount);
  
  return this.normalize(rawUsage, this.batchMin, this.batchMax);
}

// ì¤‘ë³µ ë¹„ìœ¨ ê³„ì‚°
calculateDuplicationRatio(memoryId: string, similarMemories: string[]): number {
  if (similarMemories.length === 0) return 0;
  
  const similarityScores = similarMemories.map(id => 
    this.calculateSimilarity(memoryId, id)
  );
  
  return Math.max(...similarityScores);
}
```

#### 3. ë§ê° ê²°ì •
```typescript
shouldForget(features: ForgettingFeatures, threshold: number = 0.6): boolean {
  const forgetScore = this.calculateForgetScore(features);
  return forgetScore >= threshold && !features.pinned;
}
```

## ğŸ”„ ê°„ê²© ë°˜ë³µ ì•Œê³ ë¦¬ì¦˜

### í˜„ì¬ êµ¬í˜„ ìƒíƒœ
- **íŒŒì¼**: `src/algorithms/spaced-repetition.ts` (239ì¤„)
- **ê¸°ëŠ¥**: ì¤‘ìš”ë„ì™€ ì‚¬ìš©ì„± ê¸°ë°˜ ë¦¬ë·° ê°„ê²© ê³„ì‚°
- **íŠ¹ì§•**: í”¼ë“œë°±ì— ë”°ë¥¸ ë™ì  ê°„ê²© ì¡°ì •

### í•µì‹¬ ì¸í„°í˜ì´ìŠ¤

```typescript
interface SpacedRepetitionFeatures {
  importance: number;        // ì¤‘ìš”ë„ (0-1)
  usage: number;            // ì‚¬ìš©ì„± (0-1)
  helpful_feedback: number; // ë„ì›€ë¨ í”¼ë“œë°± (0-1)
  bad_feedback: number;     // ë‚˜ì¨ í”¼ë“œë°± (0-1)
}

interface ReviewSchedule {
  memory_id: string;
  current_interval: number;  // í˜„ì¬ ê°„ê²© (ì¼)
  next_review: Date;        // ë‹¤ìŒ ë¦¬ë·° ë‚ ì§œ
  recall_probability: number; // ë¦¬ì½œ í™•ë¥ 
  needs_review: boolean;    // ë¦¬ë·° í•„ìš” ì—¬ë¶€
  multiplier: number;       // ê°„ê²© ë°°ìˆ˜
}
```

### êµ¬í˜„ ê°€ì´ë“œë¼ì¸

#### 1. ê°„ê²© ê³„ì‚°
```typescript
calculateNextInterval(
  currentInterval: number,
  features: SpacedRepetitionFeatures
): number {
  const multiplier = 1 + 
    this.weights.importance * features.importance +
    this.weights.usage * features.usage +
    this.weights.helpful_feedback * features.helpful_feedback -
    this.weights.bad_feedback * features.bad_feedback;
  
  return Math.ceil(currentInterval * multiplier);
}
```

#### 2. ë¦¬ì½œ í™•ë¥  ê³„ì‚°
```typescript
calculateRecallProbability(
  timeSinceLastReview: number,
  interval: number
): number {
  return Math.exp(-timeSinceLastReview / interval);
}
```

#### 3. ë¦¬ë·° í•„ìš” ì—¬ë¶€ íŒë‹¨
```typescript
needsReview(
  timeSinceLastReview: number,
  interval: number,
  threshold: number = 0.7
): boolean {
  const recallProb = this.calculateRecallProbability(timeSinceLastReview, interval);
  return recallProb <= threshold;
}
```

## ğŸ§  ë§ê° ì •ì±… ì„œë¹„ìŠ¤

### í˜„ì¬ êµ¬í˜„ ìƒíƒœ
- **íŒŒì¼**: `src/services/forgetting-policy-service.ts` (335ì¤„)
- **ê¸°ëŠ¥**: ë§ê° ì•Œê³ ë¦¬ì¦˜ê³¼ ê°„ê²© ë°˜ë³µì„ í†µí•©í•œ ë©”ëª¨ë¦¬ ê´€ë¦¬
- **íŠ¹ì§•**: TTL ê¸°ë°˜ ì •ì±…, ì†Œí”„íŠ¸/í•˜ë“œ ì‚­ì œ

### í•µì‹¬ ì¸í„°í˜ì´ìŠ¤

```typescript
interface ForgettingPolicyConfig {
  forgetThreshold: number;        // ë§ê° ì„ê³„ê°’ (ê¸°ë³¸: 0.6)
  softDeleteThreshold: number;    // ì†Œí”„íŠ¸ ì‚­ì œ ì„ê³„ê°’ (ê¸°ë³¸: 0.6)
  hardDeleteThreshold: number;    // í•˜ë“œ ì‚­ì œ ì„ê³„ê°’ (ê¸°ë³¸: 0.8)
  
  ttlSoft: {
    working: number;
    episodic: number;
    semantic: number;
    procedural: number;
  };
  
  ttlHard: {
    working: number;
    episodic: number;
    semantic: number;
    procedural: number;
  };
}
```

### êµ¬í˜„ ê°€ì´ë“œë¼ì¸

#### 1. ì •ì±… ì ìš©
```typescript
async applyForgettingPolicy(): Promise<ForgettingPolicyResult> {
  const memories = await this.getMemoriesForReview();
  const results: ForgettingPolicyResult = {
    softDeleted: [],
    hardDeleted: [],
    scheduledForReview: []
  };
  
  for (const memory of memories) {
    const features = await this.calculateFeatures(memory);
    const forgetScore = this.forgettingAlgorithm.calculateForgetScore(features);
    
    if (forgetScore >= this.config.hardDeleteThreshold) {
      await this.hardDelete(memory.id);
      results.hardDeleted.push(memory.id);
    } else if (forgetScore >= this.config.softDeleteThreshold) {
      await this.softDelete(memory.id);
      results.softDeleted.push(memory.id);
    } else {
      const schedule = await this.scheduleReview(memory, features);
      if (schedule.needs_review) {
        results.scheduledForReview.push(schedule);
      }
    }
  }
  
  return results;
}
```

#### 2. TTL ê²€ì‚¬
```typescript
isTTLExpired(memory: MemoryItem, type: 'soft' | 'hard'): boolean {
  const ageDays = this.getAgeInDays(memory.created_at);
  const ttl = type === 'soft' ? 
    this.config.ttlSoft[memory.type] : 
    this.config.ttlHard[memory.type];
  
  return ageDays >= ttl;
}
```

#### 3. ë°°ì¹˜ ì²˜ë¦¬
```typescript
async processBatchForgetting(batchSize: number = 100): Promise<void> {
  const memories = await this.getMemoriesBatch(batchSize);
  
  for (const memory of memories) {
    try {
      await this.processMemoryForgetting(memory);
    } catch (error) {
      console.error(`Failed to process memory ${memory.id}:`, error);
    }
  }
}
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ê°€ì´ë“œë¼ì¸

### ë§ê° ì•Œê³ ë¦¬ì¦˜ í…ŒìŠ¤íŠ¸
```typescript
describe('ForgettingAlgorithm', () => {
  let algorithm: ForgettingAlgorithm;
  
  beforeEach(() => {
    algorithm = new ForgettingAlgorithm();
  });
  
  it('should calculate forget score correctly', () => {
    const features: ForgettingFeatures = {
      recency: 0.2,
      usage: 0.1,
      duplication_ratio: 0.8,
      importance: 0.3,
      pinned: false
    };
    
    const score = algorithm.calculateForgetScore(features);
    expect(score).toBeGreaterThan(0.6);
  });
  
  it('should not forget pinned memories', () => {
    const features: ForgettingFeatures = {
      recency: 0.1,
      usage: 0.1,
      duplication_ratio: 0.9,
      importance: 0.2,
      pinned: true
    };
    
    const shouldForget = algorithm.shouldForget(features);
    expect(shouldForget).toBe(false);
  });
});
```

### ê°„ê²© ë°˜ë³µ í…ŒìŠ¤íŠ¸
```typescript
describe('SpacedRepetitionAlgorithm', () => {
  let algorithm: SpacedRepetitionAlgorithm;
  
  beforeEach(() => {
    algorithm = new SpacedRepetitionAlgorithm();
  });
  
  it('should calculate next interval correctly', () => {
    const features: SpacedRepetitionFeatures = {
      importance: 0.8,
      usage: 0.6,
      helpful_feedback: 0.7,
      bad_feedback: 0.1
    };
    
    const nextInterval = algorithm.calculateNextInterval(7, features);
    expect(nextInterval).toBeGreaterThan(7);
  });
  
  it('should determine review need correctly', () => {
    const needsReview = algorithm.needsReview(10, 7, 0.7);
    expect(needsReview).toBe(true);
  });
});
```

## ğŸ“Š ì„±ëŠ¥ ìµœì í™”

### 1. ë°°ì¹˜ ì²˜ë¦¬
```typescript
// ëŒ€ëŸ‰ ë©”ëª¨ë¦¬ ì²˜ë¦¬ ì‹œ ë°°ì¹˜ ë‹¨ìœ„ë¡œ ì²˜ë¦¬
async processMemoriesInBatches(memories: MemoryItem[], batchSize: number = 100) {
  for (let i = 0; i < memories.length; i += batchSize) {
    const batch = memories.slice(i, i + batchSize);
    await Promise.all(batch.map(memory => this.processMemory(memory)));
  }
}
```

### 2. ìºì‹±
```typescript
// íŠ¹ì§• ê³„ì‚° ê²°ê³¼ ìºì‹±
private featureCache = new Map<string, ForgettingFeatures>();

async getCachedFeatures(memoryId: string): Promise<ForgettingFeatures> {
  if (this.featureCache.has(memoryId)) {
    return this.featureCache.get(memoryId)!;
  }
  
  const features = await this.calculateFeatures(memoryId);
  this.featureCache.set(memoryId, features);
  return features;
}
```

### 3. ì¸ë±ìŠ¤ ìµœì í™”
```sql
-- ë§ê° ì •ì±… ì¿¼ë¦¬ ìµœì í™”ë¥¼ ìœ„í•œ ì¸ë±ìŠ¤
CREATE INDEX idx_memory_item_forgetting ON memory_item(
  created_at, last_accessed, importance, pinned
);

CREATE INDEX idx_memory_item_type_created ON memory_item(type, created_at);
```

## ğŸ”§ ì„¤ì • ê´€ë¦¬

### í™˜ê²½ ë³€ìˆ˜
```bash
# .env íŒŒì¼
FORGET_THRESHOLD=0.6
SOFT_DELETE_THRESHOLD=0.6
HARD_DELETE_THRESHOLD=0.8

# TTL ì„¤ì • (ì¼ ë‹¨ìœ„)
TTL_SOFT_WORKING=2
TTL_SOFT_EPISODIC=30
TTL_SOFT_SEMANTIC=180
TTL_SOFT_PROCEDURAL=90

TTL_HARD_WORKING=7
TTL_HARD_EPISODIC=180
TTL_HARD_SEMANTIC=365
TTL_HARD_PROCEDURAL=180
```

### ì„¤ì • ê²€ì¦
```typescript
private validateConfig(config: ForgettingPolicyConfig): void {
  if (config.forgetThreshold < 0 || config.forgetThreshold > 1) {
    throw new Error('forgetThreshold must be between 0 and 1');
  }
  
  if (config.softDeleteThreshold >= config.hardDeleteThreshold) {
    throw new Error('softDeleteThreshold must be less than hardDeleteThreshold');
  }
  
  // TTL ê°’ ê²€ì¦
  Object.values(config.ttlSoft).forEach(ttl => {
    if (ttl <= 0) throw new Error('TTL values must be positive');
  });
}
```

## ğŸ“‹ ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ë§ê° ì•Œê³ ë¦¬ì¦˜
- [ ] ë§ê° ì ìˆ˜ ê³„ì‚° ë¡œì§ êµ¬í˜„
- [ ] íŠ¹ì§• ê³„ì‚° í•¨ìˆ˜ êµ¬í˜„
- [ ] ë§ê° ê²°ì • ë¡œì§ êµ¬í˜„
- [ ] ì—ëŸ¬ ì²˜ë¦¬ ë° ë¡œê¹… ì¶”ê°€
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

### ê°„ê²© ë°˜ë³µ ì•Œê³ ë¦¬ì¦˜
- [ ] ê°„ê²© ê³„ì‚° ë¡œì§ êµ¬í˜„
- [ ] ë¦¬ì½œ í™•ë¥  ê³„ì‚° í•¨ìˆ˜
- [ ] ë¦¬ë·° í•„ìš” ì—¬ë¶€ íŒë‹¨ ë¡œì§
- [ ] í”¼ë“œë°± ì²˜ë¦¬ ë¡œì§
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

### ë§ê° ì •ì±… ì„œë¹„ìŠ¤
- [ ] ì •ì±… ì ìš© ë¡œì§ êµ¬í˜„
- [ ] TTL ê²€ì‚¬ ë¡œì§
- [ ] ë°°ì¹˜ ì²˜ë¦¬ êµ¬í˜„
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„±