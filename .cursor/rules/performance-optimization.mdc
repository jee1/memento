---
globs: "src/services/async-optimizer.ts,src/services/cache-service.ts,src/services/database-optimizer.ts,src/services/performance-monitor.ts"
description: ì„±ëŠ¥ ìµœì í™” ì„œë¹„ìŠ¤ ê°œë°œ ê·œì¹™
---

# ì„±ëŠ¥ ìµœì í™” ì„œë¹„ìŠ¤ ê°œë°œ ê·œì¹™

## ğŸ“‹ ì„±ëŠ¥ ìµœì í™” ì„œë¹„ìŠ¤

### í˜„ì¬ êµ¬í˜„ ìƒíƒœ
- **ë¹„ë™ê¸° ì²˜ë¦¬ ìµœì í™”**: `src/services/async-optimizer.ts` (447ì¤„)
- **ìºì‹œ ì„œë¹„ìŠ¤**: `src/services/cache-service.ts` (352ì¤„)
- **ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”**: `src/services/database-optimizer.ts` (442ì¤„)
- **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**: `src/services/performance-monitor.ts` (367ì¤„)

### í•µì‹¬ ì•„í‚¤í…ì²˜

```typescript
// ë¹„ë™ê¸° ì²˜ë¦¬ ìµœì í™”
export class AsyncTaskQueue<T = any> {
  private workers: Worker[] = [];
  private queue: Task<T>[] = [];
  private processing: Set<string> = new Set();
  private completed: Map<string, TaskResult<T>> = new Map();
  private failed: Map<string, TaskResult<T>> = new Map();
}

// ìºì‹œ ì„œë¹„ìŠ¤
export class CacheService<T = any> {
  private cache: Map<string, CacheEntry<T>> = new Map();
  private hits: number = 0;
  private misses: number = 0;
  private maxSize: number;
  private defaultTTL: number;
}

// ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”
export class DatabaseOptimizer {
  private db: sqlite3.Database;
  private queryHistory: QueryAnalysis[] = [];
  private indexRecommendations: IndexRecommendation[] = [];
}

// ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
export class PerformanceMonitor {
  private metrics: PerformanceMetrics = {
    database: { /* ... */ },
    search: { /* ... */ },
    memory: { /* ... */ },
    system: { /* ... */ }
  };
}
```

## ğŸ”§ ë¹„ë™ê¸° ì²˜ë¦¬ ìµœì í™”

### 1. ì›Œì»¤ í’€ ê´€ë¦¬

```typescript
class AsyncTaskQueue<T = any> {
  private workers: Worker[] = [];
  private maxWorkers: number;
  private queue: Task<T>[] = [];
  private processing: Set<string> = new Set();
  
  constructor(maxWorkers: number = 4) {
    this.maxWorkers = maxWorkers;
    this.initializeWorkers();
  }
  
  private initializeWorkers(): void {
    for (let i = 0; i < this.maxWorkers; i++) {
      const worker = new Worker('./worker.js');
      worker.on('message', this.handleWorkerMessage.bind(this));
      worker.on('error', this.handleWorkerError.bind(this));
      this.workers.push(worker);
    }
  }
}
```

### 2. ìš°ì„ ìˆœìœ„ í ì‹œìŠ¤í…œ

```typescript
interface Task<T = any> {
  id: string;
  type: string;
  data: any;
  priority: number;        // 1-10, ë†’ì„ìˆ˜ë¡ ìš°ì„ ìˆœìœ„
  createdAt: Date;
  maxRetries: number;
  retryCount: number;
  timeout: number;
}

class PriorityQueue<T> {
  private items: T[] = [];
  
  enqueue(item: T, priority: number): void {
    const queueElement = { item, priority };
    let added = false;
    
    for (let i = 0; i < this.items.length; i++) {
      if (queueElement.priority > this.items[i].priority) {
        this.items.splice(i, 0, queueElement);
        added = true;
        break;
      }
    }
    
    if (!added) {
      this.items.push(queueElement);
    }
  }
}
```

### 3. ë°°ì¹˜ ì²˜ë¦¬ ìµœì í™”

```typescript
async processBatch<T>(
  tasks: Task<T>[],
  batchSize: number = 10,
  delayBetweenBatches: number = 100
): Promise<TaskResult<T>[]> {
  const results: TaskResult<T>[] = [];
  
  for (let i = 0; i < tasks.length; i += batchSize) {
    const batch = tasks.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(task => this.processTask(task))
    );
    results.push(...batchResults);
    
    if (i + batchSize < tasks.length) {
      await this.delay(delayBetweenBatches);
    }
  }
  
  return results;
}
```

### 4. ì¬ì‹œë„ ë¡œì§

```typescript
async processTask<T>(task: Task<T>): Promise<TaskResult<T>> {
  const startTime = Date.now();
  let lastError: Error | null = null;
  
  for (let attempt = 0; attempt <= task.maxRetries; attempt++) {
    try {
      const result = await this.executeTask(task);
      return {
        taskId: task.id,
        success: true,
        data: result,
        executionTime: Date.now() - startTime,
        retryCount: attempt
      };
    } catch (error) {
      lastError = error as Error;
      
      if (attempt < task.maxRetries) {
        const delay = this.calculateRetryDelay(attempt);
        await this.delay(delay);
      }
    }
  }
  
  return {
    taskId: task.id,
    success: false,
    error: lastError?.message || 'Unknown error',
    executionTime: Date.now() - startTime,
    retryCount: task.maxRetries
  };
}
```

## ğŸ’¾ ìºì‹œ ì„œë¹„ìŠ¤

### 1. LRU ìºì‹œ êµ¬í˜„

```typescript
class CacheService<T = any> {
  private cache: Map<string, CacheEntry<T>> = new Map();
  private accessOrder: string[] = [];
  
  get(key: string): T | null {
    const entry = this.cache.get(key);
    
    if (!entry) {
      this.misses++;
      return null;
    }
    
    // TTL í™•ì¸
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      this.removeFromAccessOrder(key);
      this.misses++;
      return null;
    }
    
    // LRU ì—…ë°ì´íŠ¸
    this.updateAccessOrder(key);
    entry.accessCount++;
    entry.lastAccessed = Date.now();
    this.hits++;
    
    return entry.data;
  }
  
  set(key: string, data: T, ttl?: number): void {
    // ìºì‹œ í¬ê¸° í™•ì¸
    if (this.cache.size >= this.maxSize) {
      this.evictLRU();
    }
    
    const entry: CacheEntry<T> = {
      data,
      timestamp: Date.now(),
      ttl: ttl || this.defaultTTL,
      accessCount: 0,
      lastAccessed: Date.now()
    };
    
    this.cache.set(key, entry);
    this.updateAccessOrder(key);
  }
}
```

### 2. ìºì‹œ í†µê³„ ìˆ˜ì§‘

```typescript
getStats(): CacheStats {
  const totalRequests = this.hits + this.misses;
  const hitRate = totalRequests > 0 ? this.hits / totalRequests : 0;
  
  let memoryUsage = 0;
  for (const entry of this.cache.values()) {
    memoryUsage += this.estimateMemoryUsage(entry);
  }
  
  return {
    hits: this.hits,
    misses: this.misses,
    totalRequests,
    hitRate,
    size: this.cache.size,
    memoryUsage
  };
}
```

### 3. ê²€ìƒ‰ ê²°ê³¼ ìºì‹±

```typescript
class SearchCacheService extends CacheService<SearchResult[]> {
  generateCacheKey(query: string, filters?: SearchFilters): string {
    const filterStr = filters ? JSON.stringify(filters) : '';
    return `search:${query}:${filterStr}`;
  }
  
  async getCachedSearch(
    query: string,
    filters?: SearchFilters
  ): Promise<SearchResult[] | null> {
    const key = this.generateCacheKey(query, filters);
    return this.get(key);
  }
  
  async cacheSearch(
    query: string,
    results: SearchResult[],
    filters?: SearchFilters,
    ttl: number = 300000 // 5ë¶„
  ): Promise<void> {
    const key = this.generateCacheKey(query, filters);
    this.set(key, results, ttl);
  }
}
```

## ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”

### 1. ì¸ë±ìŠ¤ ì¶”ì²œ ì‹œìŠ¤í…œ

```typescript
class DatabaseOptimizer {
  async analyzeIndexes(): Promise<IndexRecommendation[]> {
    const recommendations: IndexRecommendation[] = [];
    
    // í…Œì´ë¸”ë³„ ë¶„ì„
    const tables = await this.getTables();
    for (const table of tables) {
      const queries = await this.getQueriesForTable(table);
      const analysis = await this.analyzeQueryPatterns(queries);
      
      for (const pattern of analysis.patterns) {
        if (pattern.frequency > 10 && !pattern.hasIndex) {
          recommendations.push({
            table: table.name,
            columns: pattern.columns,
            type: pattern.type,
            priority: this.calculatePriority(pattern),
            reason: `Frequent query pattern: ${pattern.query}`,
            estimatedImprovement: `${pattern.estimatedImprovement}%`
          });
        }
      }
    }
    
    return recommendations.sort((a, b) => 
      this.getPriorityValue(b.priority) - this.getPriorityValue(a.priority)
    );
  }
}
```

### 2. ì¿¼ë¦¬ ì„±ëŠ¥ ë¶„ì„

```typescript
async analyzeQuery(query: string): Promise<QueryAnalysis> {
  const startTime = Date.now();
  
  // EXPLAIN QUERY PLAN ì‹¤í–‰
  const explainPlan = await this.db.all(`EXPLAIN QUERY PLAN ${query}`);
  
  const executionTime = Date.now() - startTime;
  const complexity = this.assessComplexity(explainPlan);
  const recommendations = this.generateRecommendations(explainPlan);
  
  return {
    query,
    executionTime,
    explainPlan,
    recommendations,
    complexity
  };
}
```

### 3. ìë™ ì¸ë±ìŠ¤ ìƒì„±

```typescript
async createRecommendedIndexes(): Promise<void> {
  const recommendations = await this.analyzeIndexes();
  
  for (const rec of recommendations) {
    if (rec.priority === 'high') {
      try {
        await this.createIndex(rec);
        console.log(`âœ… Created index: ${rec.table}.${rec.columns.join(',')}`);
      } catch (error) {
        console.error(`âŒ Failed to create index: ${error.message}`);
      }
    }
  }
}

private async createIndex(rec: IndexRecommendation): Promise<void> {
  const indexName = `idx_${rec.table}_${rec.columns.join('_')}`;
  const columns = rec.columns.join(', ');
  
  let sql = `CREATE INDEX IF NOT EXISTS ${indexName} ON ${rec.table} (${columns})`;
  
  if (rec.type === 'partial') {
    sql += ` WHERE ${rec.condition}`;
  }
  
  await this.db.run(sql);
}
```

## ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

### 1. ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```typescript
class PerformanceMonitor {
  private metrics: PerformanceMetrics;
  private collectionInterval: number = 5000; // 5ì´ˆ
  private intervalId: NodeJS.Timeout | null = null;
  
  startMonitoring(): void {
    this.intervalId = setInterval(() => {
      this.collectMetrics();
    }, this.collectionInterval);
  }
  
  private async collectMetrics(): Promise<void> {
    // ë°ì´í„°ë² ì´ìŠ¤ ë©”íŠ¸ë¦­
    this.metrics.database = await this.collectDatabaseMetrics();
    
    // ê²€ìƒ‰ ë©”íŠ¸ë¦­
    this.metrics.search = await this.collectSearchMetrics();
    
    // ë©”ëª¨ë¦¬ ë©”íŠ¸ë¦­
    this.metrics.memory = await this.collectMemoryMetrics();
    
    // ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
    this.metrics.system = await this.collectSystemMetrics();
  }
}
```

### 2. ì„±ëŠ¥ ì„ê³„ê°’ ëª¨ë‹ˆí„°ë§

```typescript
interface PerformanceThresholds {
  maxResponseTime: number;
  maxMemoryUsage: number;
  minCacheHitRate: number;
  maxErrorRate: number;
}

class PerformanceMonitor {
  private thresholds: PerformanceThresholds = {
    maxResponseTime: 1000,      // 1ì´ˆ
    maxMemoryUsage: 0.8,        // 80%
    minCacheHitRate: 0.7,       // 70%
    maxErrorRate: 0.05          // 5%
  };
  
  checkThresholds(): Alert[] {
    const alerts: Alert[] = [];
    
    if (this.metrics.search.averageSearchTime > this.thresholds.maxResponseTime) {
      alerts.push({
        type: 'performance',
        severity: 'warning',
        message: `Search response time exceeded threshold: ${this.metrics.search.averageSearchTime}ms`
      });
    }
    
    if (this.metrics.memory.usage > this.thresholds.maxMemoryUsage) {
      alerts.push({
        type: 'memory',
        severity: 'critical',
        message: `Memory usage exceeded threshold: ${(this.metrics.memory.usage * 100).toFixed(1)}%`
      });
    }
    
    return alerts;
  }
}
```

### 3. ì„±ëŠ¥ ë¦¬í¬íŠ¸ ìƒì„±

```typescript
async generateReport(timeRange: string = '24h'): Promise<PerformanceReport> {
  const startTime = this.getTimeRangeStart(timeRange);
  const endTime = new Date();
  
  const report: PerformanceReport = {
    timeRange: { start: startTime, end: endTime },
    summary: {
      totalRequests: this.metrics.search.totalSearches,
      averageResponseTime: this.metrics.search.averageSearchTime,
      cacheHitRate: this.metrics.search.cacheHitRate,
      errorRate: this.calculateErrorRate(),
      memoryUsage: this.metrics.memory.usage
    },
    trends: await this.analyzeTrends(startTime, endTime),
    recommendations: await this.generateRecommendations(),
    alerts: this.checkThresholds()
  };
  
  return report;
}
```

## ğŸ§ª ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬

### 1. ë²¤ì¹˜ë§ˆí¬ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤

```typescript
class PerformanceBenchmark {
  private client: any;
  private performanceMonitor: PerformanceMonitor | null = null;
  
  async runComprehensiveBenchmark(): Promise<BenchmarkResult[]> {
    const results: BenchmarkResult[] = [];
    
    // 1. ë©”ëª¨ë¦¬ ì €ì¥ ë²¤ì¹˜ë§ˆí¬
    results.push(await this.benchmarkMemoryStorage());
    
    // 2. ê²€ìƒ‰ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
    results.push(await this.benchmarkSearchPerformance());
    
    // 3. ìºì‹œ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
    results.push(await this.benchmarkCachePerformance());
    
    // 4. ë™ì‹œì„± ë²¤ì¹˜ë§ˆí¬
    results.push(await this.benchmarkConcurrency());
    
    // 5. ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë²¤ì¹˜ë§ˆí¬
    results.push(await this.benchmarkMemoryUsage());
    
    return results;
  }
}
```

### 2. ë¶€í•˜ í…ŒìŠ¤íŠ¸

```typescript
async runLoadTest(
  concurrentUsers: number,
  requestsPerUser: number,
  duration: number
): Promise<LoadTestResult> {
  const startTime = Date.now();
  const endTime = startTime + duration;
  const results: RequestResult[] = [];
  
  const userPromises = Array.from({ length: concurrentUsers }, (_, i) =>
    this.simulateUser(i, requestsPerUser, endTime, results)
  );
  
  await Promise.all(userPromises);
  
  return this.analyzeLoadTestResults(results, startTime, endTime);
}
```

## ğŸ“‹ ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ë¹„ë™ê¸° ì²˜ë¦¬ ìµœì í™”
- [ ] ì›Œì»¤ í’€ êµ¬í˜„
- [ ] ìš°ì„ ìˆœìœ„ í ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ë°°ì¹˜ ì²˜ë¦¬ ë¡œì§ êµ¬í˜„
- [ ] ì¬ì‹œë„ ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„
- [ ] ì—ëŸ¬ ì²˜ë¦¬ ë° ë¡œê¹… ì¶”ê°€
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

### ìºì‹œ ì„œë¹„ìŠ¤
- [ ] LRU ìºì‹œ êµ¬í˜„
- [ ] TTL ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ìºì‹œ í†µê³„ ìˆ˜ì§‘ êµ¬í˜„
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ êµ¬í˜„
- [ ] ìºì‹œ ë¬´íš¨í™” ë¡œì§ êµ¬í˜„
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

### ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”
- [ ] ì¸ë±ìŠ¤ ì¶”ì²œ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì¿¼ë¦¬ ì„±ëŠ¥ ë¶„ì„ êµ¬í˜„
- [ ] ìë™ ì¸ë±ìŠ¤ ìƒì„± êµ¬í˜„
- [ ] ì¿¼ë¦¬ íˆìŠ¤í† ë¦¬ ê´€ë¦¬ êµ¬í˜„
- [ ] ì„±ëŠ¥ í†µê³„ ìˆ˜ì§‘ êµ¬í˜„
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

### ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
- [ ] ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ êµ¬í˜„
- [ ] ì„ê³„ê°’ ëª¨ë‹ˆí„°ë§ êµ¬í˜„
- [ ] ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì„±ëŠ¥ ë¦¬í¬íŠ¸ ìƒì„± êµ¬í˜„
- [ ] ëŒ€ì‹œë³´ë“œ API êµ¬í˜„
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±