---
globs: "src/services/error-logging-service.ts,src/tools/error-stats.ts,src/tools/resolve-error.ts,src/test-error-logging.ts"
description: 에러 로깅 시스템 개발 규칙
---

# 에러 로깅 시스템 개발 규칙

## 📋 에러 로깅 시스템 개요

### 현재 구현 상태
- **에러 로깅 서비스**: `src/services/error-logging-service.ts`
- **에러 통계 도구**: `src/tools/error-stats.ts`
- **에러 해결 도구**: `src/tools/resolve-error.ts`
- **에러 로깅 테스트**: `src/test-error-logging.ts`

### 핵심 인터페이스

```typescript
interface ErrorLoggingService {
  // 에러 로깅
  logError(error: Error, severity: ErrorSeverity, category: ErrorCategory, context?: Record<string, any>): void;
  
  // 에러 통계 조회
  getErrorStats(filters?: ErrorFilters): Promise<ErrorStats>;
  
  // 에러 해결
  resolveError(errorId: string, resolvedBy: string, resolution?: string): Promise<boolean>;
  
  // 에러 검색
  searchErrors(filters: ErrorSearchFilters): Promise<ErrorLog[]>;
}

enum ErrorSeverity {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH',
  CRITICAL = 'CRITICAL'
}

enum ErrorCategory {
  UNKNOWN = 'UNKNOWN',
  DATABASE = 'DATABASE',
  NETWORK = 'NETWORK',
  TOOL_EXECUTION = 'TOOL_EXECUTION',
  VALIDATION = 'VALIDATION',
  SYSTEM = 'SYSTEM'
}
```

## 🔧 에러 로깅 서비스 구현

### 1. 에러 로깅 메서드

```typescript
export class ErrorLoggingService {
  private errors: Map<string, ErrorLog> = new Map();
  private logDirectory: string;
  private maxErrors = 1000; // 최대 저장 에러 수

  constructor(logDirectory: string = './logs') {
    this.logDirectory = logDirectory;
    if (!existsSync(this.logDirectory)) {
      mkdirSync(this.logDirectory, { recursive: true });
    }
  }

  /**
   * 에러를 로깅합니다.
   */
  logError(
    error: Error,
    severity: ErrorSeverity,
    category: ErrorCategory,
    context?: Record<string, any>
  ): void {
    const id = uuidv4();
    const errorLog: ErrorLog = {
      id,
      message: error.message,
      stack: error.stack,
      severity,
      category,
      context,
      timestamp: new Date(),
      resolved: false
    };

    this.errors.set(id, errorLog);
    this.cleanupOldErrors();
    this.logToFile(errorLog);
    this.logToConsole(errorLog);
  }
}
```

### 2. 에러 통계 수집

```typescript
/**
   * 에러 통계를 반환합니다.
   */
  getErrorStats(filters?: ErrorFilters): ErrorStats {
    let filteredErrors = Array.from(this.errors.values());

    // 필터 적용
    if (filters?.severity) {
      filteredErrors = filteredErrors.filter(e => e.severity === filters.severity);
    }
    if (filters?.category) {
      filteredErrors = filteredErrors.filter(e => e.category === filters.category);
    }
    if (filters?.hours) {
      const cutoffTime = new Date(Date.now() - filters.hours * 60 * 60 * 1000);
      filteredErrors = filteredErrors.filter(e => e.timestamp >= cutoffTime);
    }

    // 통계 계산
    const total = filteredErrors.length;
    const bySeverity: Record<string, number> = {};
    const byCategory: Record<string, number> = {};
    const resolved = filteredErrors.filter(e => e.resolved).length;

    filteredErrors.forEach(error => {
      bySeverity[error.severity] = (bySeverity[error.severity] || 0) + 1;
      byCategory[error.category] = (byCategory[error.category] || 0) + 1;
    });

    return {
      total,
      resolved,
      active: total - resolved,
      bySeverity,
      byCategory,
      recentErrors: filteredErrors
        .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
        .slice(0, filters?.limit || 10)
    };
  }
```

### 3. 에러 해결 처리

```typescript
/**
   * 특정 에러를 해결 상태로 표시합니다.
   */
  resolveError(errorId: string, resolvedBy: string, resolution?: string): boolean {
    const error = this.errors.get(errorId);
    if (error) {
      error.resolved = true;
      error.resolvedAt = new Date();
      error.resolvedBy = resolvedBy;
      error.resolution = resolution;
      
      console.log(`[INFO] 에러 해결됨: ${errorId} by ${resolvedBy}`);
      this.logToFile(error); // 해결된 상태로 다시 로깅
      return true;
    }
    return false;
  }
```

## 🛠️ MCP 도구 구현

### 1. error_stats 도구

```typescript
export const errorStatsTool: ToolDefinition = {
  name: 'error_stats',
  description: '에러 통계를 조회하고 필터링된 에러 로그를 반환합니다.',
  inputSchema: z.object({
    severity: z.nativeEnum(ErrorSeverity).optional().describe('조회할 에러의 심각도 (LOW, MEDIUM, HIGH, CRITICAL).'),
    category: z.nativeEnum(ErrorCategory).optional().describe('조회할 에러의 카테고리 (UNKNOWN, DATABASE, NETWORK, TOOL_EXECUTION, VALIDATION, SYSTEM).'),
    hours: z.number().min(1).optional().describe('지난 몇 시간 동안의 에러를 조회할지 지정합니다.'),
    limit: z.number().min(1).max(100).optional().default(10).describe('반환할 에러 로그의 최대 개수.'),
  }),
  handler: async (params: z.infer<typeof errorStatsTool.inputSchema>, context: ToolContext) => {
    return executeErrorStats(params, context);
  },
};
```

### 2. resolve_error 도구

```typescript
export const resolveErrorTool: ToolDefinition = {
  name: 'resolve_error',
  description: '특정 에러를 해결 상태로 표시합니다.',
  inputSchema: z.object({
    error_id: z.string().min(1).describe('해결할 에러의 고유 ID.'),
    resolved_by: z.string().optional().default('system').describe('에러를 해결한 주체.'),
    resolution: z.string().optional().describe('에러 해결에 대한 설명.'),
  }),
  handler: async (params: z.infer<typeof resolveErrorTool.inputSchema>, context: ToolContext) => {
    return executeResolveError(params, context);
  },
};
```

## 📊 로깅 및 모니터링

### 1. 파일 로깅

```typescript
private logToFile(error: ErrorLog): void {
  const date = error.timestamp.toISOString().split('T')[0];
  const logFilePath = join(this.logDirectory, `errors-${date}.jsonl`);
  appendFileSync(logFilePath, JSON.stringify(error) + '\n');
}
```

### 2. 콘솔 로깅

```typescript
private logToConsole(error: ErrorLog): void {
  let color = '';
  switch (error.severity) {
    case ErrorSeverity.LOW:
      color = '\x1b[32m'; // Green
      break;
    case ErrorSeverity.MEDIUM:
      color = '\x1b[33m'; // Yellow
      break;
    case ErrorSeverity.HIGH:
      color = '\x1b[31m'; // Red
      break;
    case ErrorSeverity.CRITICAL:
      color = '\x1b[35m'; // Magenta
      break;
  }
  const resetColor = '\x1b[0m';
  console.error(`${color}[${error.severity}] ${error.category}${resetColor}\n  ID: ${error.id}\n  Message: ${error.message}\n  Time: ${error.timestamp.toISOString()}\n  Context: ${JSON.stringify(error.context, null, 2)}\n`);
}
```

### 3. 오래된 에러 정리

```typescript
private cleanupOldErrors(): void {
  if (this.errors.size > this.maxErrors) {
    const sortedErrors = Array.from(this.errors.values())
      .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    
    for (let i = 0; i < this.errors.size - this.maxErrors; i++) {
      this.errors.delete(sortedErrors[i].id);
    }
  }
}
```

## 🧪 테스트 작성

### 1. 에러 로깅 테스트

```typescript
// src/test-error-logging.ts
import { ErrorLoggingService, ErrorSeverity, ErrorCategory } from './services/error-logging-service.js';

async function testErrorLogging() {
  console.log('🚨 에러 로깅 시스템 테스트 시작');
  
  const errorService = new ErrorLoggingService('./logs');
  
  // 1. 다양한 심각도의 에러 로깅
  errorService.logError(
    new Error('Low severity test error'),
    ErrorSeverity.LOW,
    ErrorCategory.SYSTEM,
    { test: true, iteration: 1 }
  );
  
  errorService.logError(
    new Error('High severity test error'),
    ErrorSeverity.HIGH,
    ErrorCategory.DATABASE,
    { test: true, iteration: 2 }
  );
  
  // 2. 에러 통계 조회
  const stats = errorService.getErrorStats();
  console.log('📊 에러 통계:', stats);
  
  // 3. 에러 해결 테스트
  const errors = errorService.searchErrors({ limit: 1 });
  if (errors.length > 0) {
    const resolved = errorService.resolveError(
      errors[0].id,
      'test_user',
      '테스트 해결'
    );
    console.log('✅ 에러 해결:', resolved);
  }
}
```

## 📋 개발 체크리스트

### 에러 로깅 서비스
- [ ] ErrorLoggingService 클래스 구현
- [ ] 에러 심각도 및 카테고리 분류
- [ ] 에러 통계 수집 및 분석
- [ ] 에러 해결 추적 시스템
- [ ] 파일 및 콘솔 로깅
- [ ] 오래된 에러 자동 정리

### MCP 도구
- [ ] error_stats 도구 구현
- [ ] resolve_error 도구 구현
- [ ] 도구 등록 및 통합
- [ ] 에러 처리 및 검증

### 테스트
- [ ] 에러 로깅 테스트 스크립트
- [ ] 통합 테스트 구현
- [ ] 성능 테스트 구현
- [ ] 에러 시나리오 테스트

### 모니터링
- [ ] 실시간 에러 모니터링
- [ ] 에러 패턴 분석
- [ ] 알림 시스템 연동
- [ ] 대시보드 통합