---
globs: "src/server/http-server.ts"
description: HTTP/WebSocket ì„œë²„ ê°œë°œ ê·œì¹™
---

# HTTP/WebSocket ì„œë²„ ê°œë°œ ê·œì¹™

## ğŸ“‹ HTTP ì„œë²„ êµ¬í˜„

### í˜„ì¬ êµ¬í˜„ ìƒíƒœ
- **íŒŒì¼**: `src/server/http-server.ts` (551ì¤„)
- **ê¸°ëŠ¥**: HTTP/WebSocket ê¸°ë°˜ MCP ì„œë²„
- **íŠ¹ì§•**: CORS ì§€ì›, ì½˜ì†” ë¡œê·¸ ì¶©ëŒ í•´ê²°, ì‹¤ì‹œê°„ í†µì‹ 

### í•µì‹¬ ì•„í‚¤í…ì²˜

```typescript
// Express + WebSocket ì„œë²„
const app = express();
const server = createServer(app);
const wss = new WebSocketServer({ server });

// CORS ì„¤ì •
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',
  credentials: true
}));

// MCP í”„ë¡œí† ì½œ ì²˜ë¦¬
wss.on('connection', (ws) => {
  // WebSocket ì—°ê²° ì²˜ë¦¬
});
```

### êµ¬í˜„ ê°€ì´ë“œë¼ì¸

#### 1. ì„œë²„ ì´ˆê¸°í™”
```typescript
async function initializeHttpServer(): Promise<void> {
  try {
    // ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
    await initializeDatabase();
    
    // ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
    const searchEngine = new SearchEngine();
    const hybridSearchEngine = new HybridSearchEngine();
    const embeddingService = new MemoryEmbeddingService();
    
    // HTTP ì„œë²„ ì‹œì‘
    const PORT = process.env.PORT || 3000;
    server.listen(PORT, () => {
      console.log(`ğŸš€ HTTP MCP Server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('âŒ Server initialization failed:', error);
    process.exit(1);
  }
}
```

#### 2. WebSocket ì—°ê²° ì²˜ë¦¬
```typescript
wss.on('connection', (ws: WebSocket) => {
  console.log('ğŸ”Œ New WebSocket connection established');
  
  ws.on('message', async (data: Buffer) => {
    try {
      const message = JSON.parse(data.toString());
      const response = await handleMCPMessage(message);
      ws.send(JSON.stringify(response));
    } catch (error) {
      console.error('âŒ WebSocket message error:', error);
      ws.send(JSON.stringify({
        error: 'Invalid message format',
        code: 'INVALID_MESSAGE'
      }));
    }
  });
  
  ws.on('close', () => {
    console.log('ğŸ”Œ WebSocket connection closed');
  });
  
  ws.on('error', (error) => {
    console.error('âŒ WebSocket error:', error);
  });
});
```

#### 3. MCP ë©”ì‹œì§€ ì²˜ë¦¬
```typescript
async function handleMCPMessage(message: any): Promise<any> {
  const { method, params, id } = message;
  
  try {
    switch (method) {
      case 'tools/call':
        return await handleToolCall(params, id);
      case 'tools/list':
        return await handleToolsList(id);
      case 'resources/list':
        return await handleResourcesList(id);
      case 'resources/read':
        return await handleResourceRead(params, id);
      default:
        throw new Error(`Unknown method: ${method}`);
    }
  } catch (error) {
    return {
      error: {
        code: 'INTERNAL_ERROR',
        message: error.message
      },
      id
    };
  }
}
```

#### 4. Tool í˜¸ì¶œ ì²˜ë¦¬
```typescript
async function handleToolCall(params: any, id: string): Promise<any> {
  const { name, arguments: args } = params;
  
  try {
    switch (name) {
      case 'remember':
        const rememberResult = await rememberTool(args);
        return { content: [{ type: 'text', text: JSON.stringify(rememberResult) }], id };
      
      case 'recall':
        const recallResult = await recallTool(args);
        return { content: [{ type: 'text', text: JSON.stringify(recallResult) }], id };
      
      case 'hybrid_search':
        const hybridResult = await hybridSearchTool(args);
        return { content: [{ type: 'text', text: JSON.stringify(hybridResult) }], id };
      
      case 'forget':
        const forgetResult = await forgetTool(args);
        return { content: [{ type: 'text', text: JSON.stringify(forgetResult) }], id };
      
      case 'pin':
        const pinResult = await pinTool(args);
        return { content: [{ type: 'text', text: JSON.stringify(pinResult) }], id };
      
      case 'unpin':
        const unpinResult = await unpinTool(args);
        return { content: [{ type: 'text', text: JSON.stringify(unpinResult) }], id };
      
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    return {
      error: {
        code: 'TOOL_EXECUTION_ERROR',
        message: error.message
      },
      id
    };
  }
}
```

## ğŸ”§ CORS ë° ë³´ì•ˆ ì„¤ì •

### CORS ì„¤ì •
```typescript
// CORS ë¯¸ë“¤ì›¨ì–´ ì„¤ì •
app.use(cors({
  origin: (origin, callback) => {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['*'];
    
    if (allowedOrigins.includes('*') || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));
```

### ë³´ì•ˆ í—¤ë”
```typescript
// ë³´ì•ˆ í—¤ë” ì„¤ì •
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  next();
});
```

## ğŸ“Š ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§

### êµ¬ì¡°í™”ëœ ë¡œê¹…
```typescript
interface LogEntry {
  timestamp: string;
  level: 'info' | 'warn' | 'error';
  message: string;
  metadata?: any;
}

function log(level: 'info' | 'warn' | 'error', message: string, metadata?: any): void {
  const entry: LogEntry = {
    timestamp: new Date().toISOString(),
    level,
    message,
    metadata
  };
  
  console.log(JSON.stringify(entry));
}

// ì‚¬ìš© ì˜ˆì‹œ
log('info', 'WebSocket connection established', { clientId: 'client-123' });
log('error', 'Tool execution failed', { tool: 'remember', error: error.message });
```

### ë©”íŠ¸ë¦­ ìˆ˜ì§‘
```typescript
interface ServerMetrics {
  connections: number;
  messagesProcessed: number;
  errors: number;
  uptime: number;
}

class MetricsCollector {
  private metrics: ServerMetrics = {
    connections: 0,
    messagesProcessed: 0,
    errors: 0,
    uptime: Date.now()
  };
  
  incrementConnections(): void {
    this.metrics.connections++;
  }
  
  incrementMessages(): void {
    this.metrics.messagesProcessed++;
  }
  
  incrementErrors(): void {
    this.metrics.errors++;
  }
  
  getMetrics(): ServerMetrics {
    return {
      ...this.metrics,
      uptime: Date.now() - this.metrics.uptime
    };
  }
}
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ê°€ì´ë“œë¼ì¸

### HTTP ì„œë²„ í…ŒìŠ¤íŠ¸
```typescript
import request from 'supertest';
import { createHttpServer } from '../src/server/http-server.js';

describe('HTTP Server', () => {
  let server: any;
  
  beforeAll(async () => {
    server = await createHttpServer();
  });
  
  afterAll(async () => {
    await server.close();
  });
  
  it('should handle tool calls via HTTP', async () => {
    const response = await request(server)
      .post('/mcp')
      .send({
        method: 'tools/call',
        params: {
          name: 'remember',
          arguments: {
            content: 'Test memory',
            type: 'episodic'
          }
        },
        id: 'test-1'
      });
    
    expect(response.status).toBe(200);
    expect(response.body.id).toBe('test-1');
  });
  
  it('should handle WebSocket connections', (done) => {
    const ws = new WebSocket('ws://localhost:3000');
    
    ws.on('open', () => {
      ws.send(JSON.stringify({
        method: 'tools/list',
        id: 'test-2'
      }));
    });
    
    ws.on('message', (data) => {
      const response = JSON.parse(data.toString());
      expect(response.id).toBe('test-2');
      ws.close();
      done();
    });
  });
});
```

### WebSocket í…ŒìŠ¤íŠ¸
```typescript
import WebSocket from 'ws';

describe('WebSocket Server', () => {
  let wss: WebSocketServer;
  let ws: WebSocket;
  
  beforeAll((done) => {
    wss = new WebSocketServer({ port: 0 });
    wss.on('listening', () => {
      ws = new WebSocket(`ws://localhost:${wss.address().port}`);
      ws.on('open', done);
    });
  });
  
  afterAll(() => {
    ws.close();
    wss.close();
  });
  
  it('should handle MCP messages', (done) => {
    ws.send(JSON.stringify({
      method: 'tools/call',
      params: {
        name: 'recall',
        arguments: { query: 'test' }
      },
      id: 'test-3'
    }));
    
    ws.on('message', (data) => {
      const response = JSON.parse(data.toString());
      expect(response.id).toBe('test-3');
      done();
    });
  });
});
```

## ğŸš€ ë°°í¬ ë° ìš´ì˜

### Docker ì„¤ì •
```dockerfile
FROM node:20-alpine

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY dist/ ./dist/
EXPOSE 3000

CMD ["node", "dist/server/http-server.js"]
```

### Docker Compose
```yaml
version: '3.8'
services:
  memento-http:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - PORT=3000
      - ALLOWED_ORIGINS=http://localhost:3000,https://yourdomain.com
    volumes:
      - ./data:/app/data
    restart: unless-stopped
```

### í™˜ê²½ ë³€ìˆ˜
```bash
# .env íŒŒì¼
PORT=3000
NODE_ENV=production
ALLOWED_ORIGINS=http://localhost:3000,https://yourdomain.com
LOG_LEVEL=info
MAX_CONNECTIONS=1000
```

## ğŸ“‹ ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### HTTP ì„œë²„
- [ ] Express ì„œë²„ ì„¤ì •
- [ ] CORS ë¯¸ë“¤ì›¨ì–´ êµ¬ì„±
- [ ] ë³´ì•ˆ í—¤ë” ì„¤ì •
- [ ] ì—ëŸ¬ ì²˜ë¦¬ ë¯¸ë“¤ì›¨ì–´
- [ ] ë¡œê¹… ì‹œìŠ¤í…œ êµ¬í˜„

### WebSocket ì„œë²„
- [ ] WebSocket ì„œë²„ ì„¤ì •
- [ ] ì—°ê²° ê´€ë¦¬ ë¡œì§
- [ ] ë©”ì‹œì§€ ì²˜ë¦¬ ë¡œì§
- [ ] ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬
- [ ] ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§

### MCP í”„ë¡œí† ì½œ
- [ ] Tool í˜¸ì¶œ ì²˜ë¦¬
- [ ] Resource ì½ê¸° ì²˜ë¦¬
- [ ] ì—ëŸ¬ ì‘ë‹µ í˜•ì‹
- [ ] ë©”ì‹œì§€ ê²€ì¦
- [ ] í”„ë¡œí† ì½œ í˜¸í™˜ì„±

### í…ŒìŠ¤íŠ¸
- [ ] HTTP API í…ŒìŠ¤íŠ¸
- [ ] WebSocket ì—°ê²° í…ŒìŠ¤íŠ¸
- [ ] MCP í”„ë¡œí† ì½œ í…ŒìŠ¤íŠ¸
- [ ] í†µí•© í…ŒìŠ¤íŠ¸
- [ ] ì„±ëŠ¥ í…ŒìŠ¤íŠ¸