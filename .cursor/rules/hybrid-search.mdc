---
globs: "src/algorithms/hybrid-search-engine.ts,src/services/*.ts"
description: í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ì—”ì§„ ë° ì„ë² ë”© ì„œë¹„ìŠ¤ ê°œë°œ ê·œì¹™
---

# í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ë° ì„ë² ë”© ì„œë¹„ìŠ¤ ê·œì¹™

## ğŸ“‹ í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ì—”ì§„

### í˜„ì¬ êµ¬í˜„ ìƒíƒœ
- **íŒŒì¼**: `src/algorithms/hybrid-search-engine.ts` (200ì¤„)
- **ê¸°ëŠ¥**: FTS5 í…ìŠ¤íŠ¸ ê²€ìƒ‰ + ë²¡í„° ê²€ìƒ‰ ê²°í•©
- **ê°€ì¤‘ì¹˜**: ë²¡í„° ê²€ìƒ‰ 60%, í…ìŠ¤íŠ¸ ê²€ìƒ‰ 40% (ê¸°ë³¸ê°’)

### í•µì‹¬ ì¸í„°í˜ì´ìŠ¤

```typescript
interface HybridSearchQuery {
  query: string;
  filters?: MemorySearchFilters;
  limit?: number;
  vectorWeight?: number; // ë²¡í„° ê²€ìƒ‰ ê°€ì¤‘ì¹˜ (0.0 ~ 1.0)
  textWeight?: number;   // í…ìŠ¤íŠ¸ ê²€ìƒ‰ ê°€ì¤‘ì¹˜ (0.0 ~ 1.0)
}

interface HybridSearchResult {
  id: string;
  content: string;
  type: string;
  importance: number;
  created_at: string;
  last_accessed?: string;
  pinned: boolean;
  tags?: string[];
  textScore: number;    // FTS5 í…ìŠ¤íŠ¸ ê²€ìƒ‰ ì ìˆ˜
  vectorScore: number;  // ë²¡í„° ìœ ì‚¬ë„ ì ìˆ˜
  finalScore: number;   // ìµœì¢… ê²°í•© ì ìˆ˜
  recall_reason: string;
}
```

### êµ¬í˜„ ê°€ì´ë“œë¼ì¸

#### 1. ê°€ì¤‘ì¹˜ ê´€ë¦¬
```typescript
// ê¸°ë³¸ ê°€ì¤‘ì¹˜ ì„¤ì •
private readonly defaultVectorWeight = 0.6; // ë²¡í„° ê²€ìƒ‰ 60%
private readonly defaultTextWeight = 0.4;   // í…ìŠ¤íŠ¸ ê²€ìƒ‰ 40%

// ê°€ì¤‘ì¹˜ ê²€ì¦
private validateWeights(vectorWeight: number, textWeight: number): void {
  if (vectorWeight < 0 || vectorWeight > 1) {
    throw new Error('vectorWeight must be between 0 and 1');
  }
  if (textWeight < 0 || textWeight > 1) {
    throw new Error('textWeight must be between 0 and 1');
  }
  if (Math.abs(vectorWeight + textWeight - 1.0) > 0.01) {
    throw new Error('vectorWeight + textWeight must equal 1.0');
  }
}
```

#### 2. ì ìˆ˜ ì •ê·œí™”
```typescript
// ì ìˆ˜ ì •ê·œí™” (0-1 ë²”ìœ„ë¡œ ë³€í™˜)
private normalizeScore(score: number, min: number, max: number): number {
  if (max === min) return 0.5; // ëª¨ë“  ì ìˆ˜ê°€ ê°™ì„ ë•Œ
  return (score - min) / (max - min);
}
```

#### 3. ê²°ê³¼ ê²°í•©
```typescript
// í•˜ì´ë¸Œë¦¬ë“œ ì ìˆ˜ ê³„ì‚°
private calculateHybridScore(
  textScore: number,
  vectorScore: number,
  vectorWeight: number,
  textWeight: number
): number {
  return vectorWeight * vectorScore + textWeight * textScore;
}
```

## ğŸ§  ì„ë² ë”© ì„œë¹„ìŠ¤

### í˜„ì¬ êµ¬í˜„ ìƒíƒœ
- **íŒŒì¼**: `src/services/embedding-service.ts` (196ì¤„)
- **ëª¨ë¸**: OpenAI `text-embedding-3-small` (1536ì°¨ì›)
- **ê¸°ëŠ¥**: í…ìŠ¤íŠ¸ ë²¡í„°í™”, ìœ ì‚¬ë„ ê²€ìƒ‰

### í•µì‹¬ ì¸í„°í˜ì´ìŠ¤

```typescript
interface EmbeddingResult {
  embedding: number[];
  model: string;
  usage: {
    prompt_tokens: number;
    total_tokens: number;
  };
}

interface SimilarityResult {
  id: string;
  content: string;
  similarity: number;
  score: number;
}
```

### êµ¬í˜„ ê°€ì´ë“œë¼ì¸

#### 1. OpenAI API ì´ˆê¸°í™”
```typescript
private initializeOpenAI(): void {
  if (!mementoConfig.openaiApiKey) {
    console.warn('âš ï¸ OpenAI API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
    return;
  }

  try {
    this.openai = new OpenAI({
      apiKey: mementoConfig.openaiApiKey,
    });
    console.log('âœ… OpenAI ì„ë² ë”© ì„œë¹„ìŠ¤ ì´ˆê¸°í™” ì™„ë£Œ');
  } catch (error) {
    console.error('âŒ OpenAI ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
    this.openai = null;
  }
}
```

#### 2. í…ìŠ¤íŠ¸ ì „ì²˜ë¦¬
```typescript
private preprocessText(text: string): string {
  // í† í° ì œí•œ í™•ì¸
  if (text.length > this.maxTokens * 4) { // ëŒ€ëµì ì¸ ë¬¸ì-í† í° ë¹„ìœ¨
    text = text.substring(0, this.maxTokens * 4);
    console.warn('âš ï¸ í…ìŠ¤íŠ¸ê°€ ë„ˆë¬´ ê¸¸ì–´ ì˜ë ¸ìŠµë‹ˆë‹¤.');
  }
  
  return text.trim();
}
```

#### 3. ìœ ì‚¬ë„ ê³„ì‚°
```typescript
private calculateCosineSimilarity(a: number[], b: number[]): number {
  if (a.length !== b.length) {
    throw new Error('ë²¡í„° ì°¨ì›ì´ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
  }

  const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
  const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
  const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));

  if (magnitudeA === 0 || magnitudeB === 0) {
    return 0;
  }

  return dotProduct / (magnitudeA * magnitudeB);
}
```

## ğŸ”— ë©”ëª¨ë¦¬ ì„ë² ë”© ì„œë¹„ìŠ¤

### í˜„ì¬ êµ¬í˜„ ìƒíƒœ
- **íŒŒì¼**: `src/services/memory-embedding-service.ts` (237ì¤„)
- **ê¸°ëŠ¥**: ë©”ëª¨ë¦¬ì™€ ì„ë² ë”©ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ ë° ê²€ìƒ‰

### í•µì‹¬ ì¸í„°í˜ì´ìŠ¤

```typescript
interface MemoryEmbedding {
  memory_id: string;
  embedding: number[];
  created_at: string;
}

interface VectorSearchResult {
  id: string;
  content: string;
  type: string;
  importance: number;
  created_at: string;
  last_accessed?: string;
  pinned: boolean;
  tags?: string[];
  similarity: number;
  score: number;
}
```

### êµ¬í˜„ ê°€ì´ë“œë¼ì¸

#### 1. ì„ë² ë”© ì €ì¥
```typescript
async createAndStoreEmbedding(
  db: any,
  memoryId: string,
  content: string,
  type: MemoryType
): Promise<EmbeddingResult | null> {
  if (!this.embeddingService.isAvailable()) {
    console.warn('âš ï¸ ì„ë² ë”© ì„œë¹„ìŠ¤ê°€ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.');
    return null;
  }

  try {
    // ì„ë² ë”© ìƒì„±
    const embeddingResult = await this.embeddingService.createEmbedding(content);
    
    // ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
    await this.storeEmbedding(db, memoryId, embeddingResult.embedding);
    
    return embeddingResult;
  } catch (error) {
    console.error('âŒ ì„ë² ë”© ìƒì„± ë° ì €ì¥ ì‹¤íŒ¨:', error);
    return null;
  }
}
```

#### 2. ë²¡í„° ê²€ìƒ‰
```typescript
async searchSimilarMemories(
  db: any,
  query: string,
  limit: number = 10,
  threshold: number = 0.7
): Promise<VectorSearchResult[]> {
  if (!this.embeddingService.isAvailable()) {
    return [];
  }

  try {
    // ì¿¼ë¦¬ ì„ë² ë”© ìƒì„±
    const queryEmbedding = await this.embeddingService.createEmbedding(query);
    
    // ìœ ì‚¬ë„ ê²€ìƒ‰
    const results = await this.performVectorSearch(
      db, 
      queryEmbedding.embedding, 
      limit, 
      threshold
    );
    
    return results;
  } catch (error) {
    console.error('âŒ ë²¡í„° ê²€ìƒ‰ ì‹¤íŒ¨:', error);
    return [];
  }
}
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ê°€ì´ë“œë¼ì¸

### í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ í…ŒìŠ¤íŠ¸
```typescript
// í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ í…ŒìŠ¤íŠ¸
describe('HybridSearchEngine', () => {
  let hybridEngine: HybridSearchEngine;
  let mockDb: any;

  beforeEach(() => {
    hybridEngine = new HybridSearchEngine();
    mockDb = createMockDatabase();
  });

  it('should combine text and vector search results', async () => {
    const query = {
      query: "React Hook ì‚¬ìš©ë²•",
      vectorWeight: 0.6,
      textWeight: 0.4,
      limit: 5
    };

    const results = await hybridEngine.search(mockDb, query);
    
    expect(results).toHaveLength(5);
    expect(results[0]).toHaveProperty('textScore');
    expect(results[0]).toHaveProperty('vectorScore');
    expect(results[0]).toHaveProperty('finalScore');
  });
});
```

### ì„ë² ë”© ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸
```typescript
// ì„ë² ë”© ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸
describe('EmbeddingService', () => {
  let embeddingService: EmbeddingService;

  beforeEach(() => {
    embeddingService = new EmbeddingService();
  });

  it('should create embedding for text', async () => {
    const text = "React Hookì— ëŒ€í•´ ì„¤ëª…í•©ë‹ˆë‹¤.";
    const result = await embeddingService.createEmbedding(text);
    
    expect(result.embedding).toHaveLength(1536);
    expect(result.model).toBe('text-embedding-3-small');
  });

  it('should calculate similarity correctly', async () => {
    const text1 = "React Hook ì‚¬ìš©ë²•";
    const text2 = "React Hookì— ëŒ€í•œ ì„¤ëª…";
    
    const similarity = await embeddingService.calculateSimilarity(text1, text2);
    
    expect(similarity).toBeGreaterThan(0.5);
    expect(similarity).toBeLessThanOrEqual(1.0);
  });
});
```

## ğŸ“Š ì„±ëŠ¥ ìµœì í™”

### 1. ì„ë² ë”© ìºì‹±
```typescript
// ì„ë² ë”© ê²°ê³¼ ìºì‹±
private embeddingCache = new Map<string, EmbeddingResult>();

async createEmbedding(text: string): Promise<EmbeddingResult> {
  const cacheKey = this.generateCacheKey(text);
  
  if (this.embeddingCache.has(cacheKey)) {
    return this.embeddingCache.get(cacheKey)!;
  }

  const result = await this.callOpenAI(text);
  this.embeddingCache.set(cacheKey, result);
  
  return result;
}
```

### 2. ë°°ì¹˜ ì²˜ë¦¬
```typescript
// ì—¬ëŸ¬ í…ìŠ¤íŠ¸ë¥¼ í•œ ë²ˆì— ì„ë² ë”©
async createEmbeddingsBatch(texts: string[]): Promise<EmbeddingResult[]> {
  const results = await this.openai.embeddings.create({
    model: this.model,
    input: texts,
  });

  return results.data.map(item => ({
    embedding: item.embedding,
    model: item.model,
    usage: results.usage
  }));
}
```

### 3. ì—ëŸ¬ ì²˜ë¦¬
```typescript
// ì¬ì‹œë„ ë¡œì§
async createEmbeddingWithRetry(text: string, maxRetries: number = 3): Promise<EmbeddingResult> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await this.createEmbedding(text);
    } catch (error) {
      if (attempt === maxRetries) {
        throw new Error(`ì„ë² ë”© ìƒì„± ì‹¤íŒ¨ (${maxRetries}íšŒ ì‹œë„): ${error.message}`);
      }
      
      const delay = Math.pow(2, attempt - 1) * 1000; // ì§€ìˆ˜ ë°±ì˜¤í”„
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

## ğŸ”§ ì„¤ì • ê´€ë¦¬

### í™˜ê²½ ë³€ìˆ˜
```bash
# .env íŒŒì¼
OPENAI_API_KEY=your_openai_api_key_here
EMBEDDING_MODEL=text-embedding-3-small
EMBEDDING_MAX_TOKENS=8191
VECTOR_WEIGHT=0.6
TEXT_WEIGHT=0.4
```

### ì„¤ì • ê²€ì¦
```typescript
// ì„¤ì • ê²€ì¦
private validateConfig(): void {
  if (!mementoConfig.openaiApiKey) {
    throw new Error('OPENAI_API_KEYê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
  }
  
  if (mementoConfig.vectorWeight + mementoConfig.textWeight !== 1.0) {
    throw new Error('ë²¡í„° ê°€ì¤‘ì¹˜ì™€ í…ìŠ¤íŠ¸ ê°€ì¤‘ì¹˜ì˜ í•©ì´ 1.0ì´ì–´ì•¼ í•©ë‹ˆë‹¤');
  }
}
```

## ğŸ“‹ ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ì—”ì§„
- [ ] ê°€ì¤‘ì¹˜ ê²€ì¦ ë¡œì§ êµ¬í˜„
- [ ] ì ìˆ˜ ì •ê·œí™” í•¨ìˆ˜ êµ¬í˜„
- [ ] ê²°ê³¼ ê²°í•© ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
- [ ] ì—ëŸ¬ ì²˜ë¦¬ ë° ë¡œê¹… ì¶”ê°€
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

### ì„ë² ë”© ì„œë¹„ìŠ¤
- [ ] OpenAI API ì´ˆê¸°í™” ë¡œì§
- [ ] í…ìŠ¤íŠ¸ ì „ì²˜ë¦¬ í•¨ìˆ˜
- [ ] ìœ ì‚¬ë„ ê³„ì‚° í•¨ìˆ˜
- [ ] ìºì‹± ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„
- [ ] ì¬ì‹œë„ ë¡œì§ êµ¬í˜„

### ë©”ëª¨ë¦¬ ì„ë² ë”© ì„œë¹„ìŠ¤
- [ ] ì„ë² ë”© ì €ì¥ ë¡œì§
- [ ] ë²¡í„° ê²€ìƒ‰ êµ¬í˜„
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™
- [ ] ì„±ëŠ¥ ìµœì í™”
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„±