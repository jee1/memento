---
globs: *.test.ts,*.spec.ts,*.test.js,*.spec.js
description: í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ì‹¤í–‰ ê·œì¹™
---

# í…ŒìŠ¤íŠ¸ ê·œì¹™

## ğŸ§ª í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬

### Jest ì„¤ì •
```json
{
  "jest": {
    "preset": "ts-jest",
    "testEnvironment": "node",
    "roots": ["<rootDir>/src", "<rootDir>/tests"],
    "testMatch": ["**/__tests__/**/*.ts", "**/?(*.)+(spec|test).ts"],
    "collectCoverageFrom": [
      "src/**/*.ts",
      "!src/**/*.d.ts",
      "!src/**/index.ts"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

## ğŸ“ í…ŒìŠ¤íŠ¸ ì‘ì„± ê·œì¹™

### íŒŒì¼ ëª…ëª…
- **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸**: `*.test.ts`
- **í†µí•© í…ŒìŠ¤íŠ¸**: `*.integration.test.ts`
- **E2E í…ŒìŠ¤íŠ¸**: `*.e2e.test.ts`
- **í”½ìŠ¤ì²˜**: `*.fixture.ts`

### í…ŒìŠ¤íŠ¸ êµ¬ì¡° (AAA íŒ¨í„´)
```typescript
describe('MemoryManager', () => {
  describe('remember', () => {
    it('should store memory successfully', async () => {
      // Arrange (ì¤€ë¹„)
      const memoryManager = new MemoryManager(mockClient);
      const content = 'Test memory content';
      const options = { type: 'episodic', importance: 0.8 };
      
      // Act (ì‹¤í–‰)
      const result = await memoryManager.remember(content, options);
      
      // Assert (ê²€ì¦)
      expect(result).toBeDefined();
      expect(typeof result).toBe('string');
    });
  });
});
```

## ğŸ”§ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

### MCP Tools í…ŒìŠ¤íŠ¸
```typescript
// tests/unit/tools/remember.test.ts
import { RememberTool } from '@/server/tools/remember';
import { MemoryRepository } from '@/server/database/memory-repository';

describe('RememberTool', () => {
  let rememberTool: RememberTool;
  let mockRepository: jest.Mocked<MemoryRepository>;
  
  beforeEach(() => {
    mockRepository = {
      create: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      delete: jest.fn()
    } as any;
    
    rememberTool = new RememberTool(mockRepository);
  });
  
  it('should create memory with valid parameters', async () => {
    // Given
    const params = {
      content: 'Test content',
      type: 'episodic',
      importance: 0.8
    };
    
    mockRepository.create.mockResolvedValue('memory-123');
    
    // When
    const result = await rememberTool.execute(params);
    
    // Then
    expect(result).toEqual({ memory_id: 'memory-123' });
    expect(mockRepository.create).toHaveBeenCalledWith({
      content: 'Test content',
      type: 'episodic',
      importance: 0.8,
      created_at: expect.any(Date)
    });
  });
  
  it('should throw error for invalid content', async () => {
    // Given
    const params = { content: '', type: 'episodic' };
    
    // When & Then
    await expect(rememberTool.execute(params))
      .rejects
      .toThrow('Content cannot be empty');
  });
});
```

### ì•Œê³ ë¦¬ì¦˜ í…ŒìŠ¤íŠ¸
```typescript
// tests/unit/algorithms/search-ranking.test.ts
import { SearchRanking } from '@/algorithms/search-ranking';

describe('SearchRanking', () => {
  let searchRanking: SearchRanking;
  
  beforeEach(() => {
    searchRanking = new SearchRanking();
  });
  
  describe('calculateFinalScore', () => {
    it('should calculate correct final score', () => {
      // Given
      const features = {
        relevance: 0.8,
        recency: 0.6,
        importance: 0.7,
        usage: 0.5,
        duplication_penalty: 0.2
      };
      
      // When
      const score = searchRanking.calculateFinalScore(features);
      
      // Then
      expect(score).toBeCloseTo(0.8 * 0.5 + 0.6 * 0.2 + 0.7 * 0.2 + 0.5 * 0.1 - 0.2 * 0.15);
    });
  });
});
```

## ğŸ”— í†µí•© í…ŒìŠ¤íŠ¸

### MCP ì„œë²„ í†µí•© í…ŒìŠ¤íŠ¸
```typescript
// tests/integration/mcp-server.test.ts
import { MCPClient } from '@modelcontextprotocol/sdk';
import { MCPServer } from '@/server';

describe('MCP Server Integration', () => {
  let server: MCPServer;
  let client: MCPClient;
  
  beforeAll(async () => {
    // ì„œë²„ ì‹œì‘
    server = new MCPServer();
    await server.start();
    
    // í´ë¼ì´ì–¸íŠ¸ ì—°ê²°
    client = new MCPClient({
      name: 'test-client',
      version: '1.0.0'
    });
    await client.connect({
      command: 'node',
      args: ['dist/server/index.js']
    });
  });
  
  afterAll(async () => {
    await client.close();
    await server.stop();
  });
  
  it('should handle remember tool', async () => {
    // Given
    const params = {
      content: 'Integration test memory',
      type: 'episodic'
    };
    
    // When
    const result = await client.callTool('remember', params);
    
    // Then
    expect(result).toHaveProperty('memory_id');
    expect(typeof result.memory_id).toBe('string');
  });
  
  it('should handle recall tool', async () => {
    // Given
    const query = 'test memory';
    
    // When
    const result = await client.callTool('recall', { query });
    
    // Then
    expect(Array.isArray(result.items)).toBe(true);
  });
});
```

### ë°ì´í„°ë² ì´ìŠ¤ í†µí•© í…ŒìŠ¤íŠ¸
```typescript
// tests/integration/database.test.ts
import { Database } from '@/server/database';
import { MemoryItem } from '@/shared/types';

describe('Database Integration', () => {
  let db: Database;
  
  beforeAll(async () => {
    db = new Database(':memory:'); // ì¸ë©”ëª¨ë¦¬ SQLite
    await db.initialize();
  });
  
  afterAll(async () => {
    await db.close();
  });
  
  beforeEach(async () => {
    await db.clear(); // ê° í…ŒìŠ¤íŠ¸ ì „ ë°ì´í„° ì •ë¦¬
  });
  
  it('should create and retrieve memory', async () => {
    // Given
    const memory: Omit<MemoryItem, 'id' | 'created_at'> = {
      content: 'Test memory',
      type: 'episodic',
      importance: 0.8
    };
    
    // When
    const created = await db.createMemory(memory);
    const retrieved = await db.getMemory(created.id);
    
    // Then
    expect(retrieved).toMatchObject(memory);
    expect(retrieved.id).toBe(created.id);
  });
});
```

## ğŸ­ Mock ë° Stub

### MCP í´ë¼ì´ì–¸íŠ¸ Mock
```typescript
// tests/mocks/mcp-client.mock.ts
export class MockMCPClient {
  private tools: Map<string, jest.Mock> = new Map();
  
  constructor() {
    this.setupDefaultMocks();
  }
  
  private setupDefaultMocks() {
    this.tools.set('remember', jest.fn().mockResolvedValue({ memory_id: 'mock-123' }));
    this.tools.set('recall', jest.fn().mockResolvedValue({ items: [] }));
    this.tools.set('forget', jest.fn().mockResolvedValue({ success: true }));
  }
  
  async callTool(name: string, params: any) {
    const mock = this.tools.get(name);
    if (!mock) {
      throw new Error(`Tool ${name} not found`);
    }
    return mock(params);
  }
  
  setMockTool(name: string, mock: jest.Mock) {
    this.tools.set(name, mock);
  }
}
```

### ë°ì´í„°ë² ì´ìŠ¤ Mock
```typescript
// tests/mocks/database.mock.ts
export class MockDatabase {
  private memories: Map<string, MemoryItem> = new Map();
  
  async createMemory(memory: Omit<MemoryItem, 'id' | 'created_at'>): Promise<MemoryItem> {
    const id = `memory-${Date.now()}`;
    const created: MemoryItem = {
      ...memory,
      id,
      created_at: new Date()
    };
    this.memories.set(id, created);
    return created;
  }
  
  async getMemory(id: string): Promise<MemoryItem | null> {
    return this.memories.get(id) || null;
  }
  
  async searchMemories(query: string): Promise<MemoryItem[]> {
    return Array.from(this.memories.values())
      .filter(memory => memory.content.includes(query));
  }
}
```

## ğŸ“Š í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€

### ì»¤ë²„ë¦¬ì§€ ì„¤ì •
```json
{
  "jest": {
    "collectCoverageFrom": [
      "src/**/*.ts",
      "!src/**/*.d.ts",
      "!src/**/index.ts",
      "!src/**/*.test.ts",
      "!src/**/*.spec.ts"
    ],
    "coverageReporters": ["text", "lcov", "html"],
    "coverageDirectory": "coverage"
  }
}
```

### ì»¤ë²„ë¦¬ì§€ ì„ê³„ê°’
```json
{
  "jest": {
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      },
      "./src/server/": {
        "branches": 90,
        "functions": 90,
        "lines": 90,
        "statements": 90
      }
    }
  }
}
```

## ğŸš€ í…ŒìŠ¤íŠ¸ ì‹¤í–‰

### npm ìŠ¤í¬ë¦½íŠ¸
```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:unit": "jest --testPathPattern=unit",
    "test:integration": "jest --testPathPattern=integration",
    "test:e2e": "jest --testPathPattern=e2e",
    "test:ci": "jest --ci --coverage --watchAll=false"
  }
}
```

### í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ëª…ë ¹ì–´
```bash
# ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰
npm test

# ê°ì‹œ ëª¨ë“œ
npm run test:watch

# ì»¤ë²„ë¦¬ì§€ í¬í•¨
npm run test:coverage

# ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë§Œ
npm run test:unit

# í†µí•© í…ŒìŠ¤íŠ¸ë§Œ
npm run test:integration

# CI í™˜ê²½
npm run test:ci
```

## ğŸ” í…ŒìŠ¤íŠ¸ ë””ë²„ê¹…

### Jest ë””ë²„ê¹…
```bash
# íŠ¹ì • í…ŒìŠ¤íŠ¸ ë””ë²„ê¹…
npm test -- --testNamePattern="should create memory"

# ìƒì„¸ ë¡œê·¸
npm test -- --verbose

# ì‹¤íŒ¨í•œ í…ŒìŠ¤íŠ¸ë§Œ ì¬ì‹¤í–‰
npm test -- --onlyFailures
```

### VS Code ë””ë²„ê¹… ì„¤ì •
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Jest Tests",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/node_modules/.bin/jest",
      "args": ["--runInBand"],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    }
  ]
}
```

## ğŸ“‹ í…ŒìŠ¤íŠ¸ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
- [ ] ëª¨ë“  public ë©”ì„œë“œ í…ŒìŠ¤íŠ¸
- [ ] ê²½ê³„ê°’ í…ŒìŠ¤íŠ¸ (null, undefined, ë¹ˆ ë¬¸ìì—´)
- [ ] ì˜ˆì™¸ ìƒí™© í…ŒìŠ¤íŠ¸
- [ ] Mock ì‚¬ìš©ìœ¼ë¡œ ì™¸ë¶€ ì˜ì¡´ì„± ê²©ë¦¬

### í†µí•© í…ŒìŠ¤íŠ¸
- [ ] MCP ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ í†µì‹ 
- [ ] ë°ì´í„°ë² ì´ìŠ¤ CRUD ì‘ì—…
- [ ] ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ ë™ì‘
- [ ] ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬

### E2E í…ŒìŠ¤íŠ¸
- [ ] ì „ì²´ ì›Œí¬í”Œë¡œìš° í…ŒìŠ¤íŠ¸
- [ ] ì‚¬ìš©ì ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
- [ ] ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] ë³´ì•ˆ í…ŒìŠ¤íŠ¸

## ğŸ¯ í…ŒìŠ¤íŠ¸ ëª¨ë²” ì‚¬ë¡€

### 1. í…ŒìŠ¤íŠ¸ ëª…ëª…
- **Given-When-Then** íŒ¨í„´ ì‚¬ìš©
- êµ¬ì²´ì ì´ê³  ëª…í™•í•œ í…ŒìŠ¤íŠ¸ ì´ë¦„
- ì˜ˆ: `should return error when content is empty`

### 2. í…ŒìŠ¤íŠ¸ ê²©ë¦¬
- ê° í…ŒìŠ¤íŠ¸ëŠ” ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ ê°€ëŠ¥
- ê³µìœ  ìƒíƒœ ì‚¬ìš© ê¸ˆì§€
- í…ŒìŠ¤íŠ¸ ê°„ ì˜ì¡´ì„± ì œê±°

### 3. í…ŒìŠ¤íŠ¸ ë°ì´í„°
- í”½ìŠ¤ì²˜ íŒŒì¼ë¡œ í…ŒìŠ¤íŠ¸ ë°ì´í„° ê´€ë¦¬
- ì‹¤ì œ ë°ì´í„°ì™€ ìœ ì‚¬í•œ í…ŒìŠ¤íŠ¸ ë°ì´í„° ì‚¬ìš©
- ë¯¼ê°í•œ ì •ë³´ëŠ” ë§ˆìŠ¤í‚¹

### 4. ì—ëŸ¬ í…ŒìŠ¤íŠ¸
- ì •ìƒ ì¼€ì´ìŠ¤ì™€ ì—ëŸ¬ ì¼€ì´ìŠ¤ ëª¨ë‘ í…ŒìŠ¤íŠ¸
- ì˜ˆì™¸ ë©”ì‹œì§€ ê²€ì¦
- ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸

### 5. ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
- ì‘ë‹µ ì‹œê°„ ì¸¡ì •
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
- ë™ì‹œì„± í…ŒìŠ¤íŠ¸