---
globs: "src/services/cache-service.ts"
description: ìºì‹œ ì„œë¹„ìŠ¤ ê°œë°œ ê·œì¹™
---

# ìºì‹œ ì„œë¹„ìŠ¤ ê°œë°œ ê·œì¹™

## ğŸ“‹ ìºì‹œ ì„œë¹„ìŠ¤

### í˜„ì¬ êµ¬í˜„ ìƒíƒœ
- **íŒŒì¼**: `src/services/cache-service.ts` (352ì¤„)
- **ê¸°ëŠ¥**: ë©”ëª¨ë¦¬ ìºì‹±, ê²€ìƒ‰ ê²°ê³¼ ìºì‹±, ì„±ëŠ¥ ìµœì í™”
- **íŠ¹ì§•**: LRU ì •ì±…, TTL ê´€ë¦¬, í†µê³„ ìˆ˜ì§‘

### í•µì‹¬ ì¸í„°í˜ì´ìŠ¤

```typescript
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
  accessCount: number;
  lastAccessed: number;
}

interface CacheStats {
  hits: number;
  misses: number;
  totalRequests: number;
  hitRate: number;
  size: number;
  memoryUsage: number;
}

interface CacheConfig {
  maxSize: number;
  defaultTTL: number;
  cleanupInterval: number;
  enableStatistics: boolean;
}
```

## ğŸ”§ ìºì‹œ ì„œë¹„ìŠ¤ êµ¬í˜„

### 1. ê¸°ë³¸ ìºì‹œ ì„œë¹„ìŠ¤

```typescript
export class CacheService<T = any> {
  private cache: Map<string, CacheEntry<T>> = new Map();
  private accessOrder: string[] = [];
  private hits: number = 0;
  private misses: number = 0;
  private maxSize: number;
  private defaultTTL: number;
  private cleanupInterval: NodeJS.Timeout | null = null;

  constructor(
    maxSize: number = 1000,
    defaultTTL: number = 300000, // 5ë¶„
    cleanupInterval: number = 60000 // 1ë¶„
  ) {
    this.maxSize = maxSize;
    this.defaultTTL = defaultTTL;
    this.startCleanup(cleanupInterval);
  }
}
```

### 2. ìºì‹œ ì¡°íšŒ (GET)

```typescript
get(key: string): T | null {
  const entry = this.cache.get(key);
  
  if (!entry) {
    this.misses++;
    return null;
  }
  
  // TTL í™•ì¸
  if (this.isExpired(entry)) {
    this.cache.delete(key);
    this.removeFromAccessOrder(key);
    this.misses++;
    return null;
  }
  
  // LRU ì—…ë°ì´íŠ¸
  this.updateAccessOrder(key);
  entry.accessCount++;
  entry.lastAccessed = Date.now();
  this.hits++;
  
  return entry.data;
}

private isExpired(entry: CacheEntry<T>): boolean {
  return Date.now() - entry.timestamp > entry.ttl;
}
```

### 3. ìºì‹œ ì €ì¥ (SET)

```typescript
set(key: string, data: T, ttl?: number): void {
  // ìºì‹œ í¬ê¸° í™•ì¸ ë° LRU ì œê±°
  if (this.cache.size >= this.maxSize) {
    this.evictLRU();
  }
  
  const entry: CacheEntry<T> = {
    data,
    timestamp: Date.now(),
    ttl: ttl || this.defaultTTL,
    accessCount: 0,
    lastAccessed: Date.now()
  };
  
  this.cache.set(key, entry);
  this.updateAccessOrder(key);
}
```

### 4. LRU ì œê±° ë¡œì§

```typescript
private evictLRU(): void {
  if (this.accessOrder.length === 0) return;
  
  const lruKey = this.accessOrder[0];
  this.cache.delete(lruKey);
  this.removeFromAccessOrder(lruKey);
}

private updateAccessOrder(key: string): void {
  // ê¸°ì¡´ ìœ„ì¹˜ì—ì„œ ì œê±°
  this.removeFromAccessOrder(key);
  // ë§¨ ë’¤ì— ì¶”ê°€ (ê°€ì¥ ìµœê·¼ ì‚¬ìš©)
  this.accessOrder.push(key);
}

private removeFromAccessOrder(key: string): void {
  const index = this.accessOrder.indexOf(key);
  if (index > -1) {
    this.accessOrder.splice(index, 1);
  }
}
```

### 5. ìºì‹œ ë¬´íš¨í™”

```typescript
delete(key: string): boolean {
  const deleted = this.cache.delete(key);
  if (deleted) {
    this.removeFromAccessOrder(key);
  }
  return deleted;
}

clear(): void {
  this.cache.clear();
  this.accessOrder = [];
  this.hits = 0;
  this.misses = 0;
}

invalidatePattern(pattern: RegExp): number {
  let invalidatedCount = 0;
  
  for (const key of this.cache.keys()) {
    if (pattern.test(key)) {
      this.delete(key);
      invalidatedCount++;
    }
  }
  
  return invalidatedCount;
}
```

## ğŸ” ê²€ìƒ‰ ê²°ê³¼ ìºì‹±

### 1. ê²€ìƒ‰ ìºì‹œ ì„œë¹„ìŠ¤

```typescript
export class SearchCacheService extends CacheService<SearchResult[]> {
  private queryCache: Map<string, string> = new Map();
  
  generateCacheKey(query: string, filters?: SearchFilters): string {
    const filterStr = filters ? this.serializeFilters(filters) : '';
    const normalizedQuery = this.normalizeQuery(query);
    return `search:${normalizedQuery}:${filterStr}`;
  }
  
  private normalizeQuery(query: string): string {
    return query.toLowerCase().trim().replace(/\s+/g, ' ');
  }
  
  private serializeFilters(filters: SearchFilters): string {
    const sorted = Object.keys(filters)
      .sort()
      .reduce((result, key) => {
        result[key] = filters[key];
        return result;
      }, {} as any);
    
    return JSON.stringify(sorted);
  }
}
```

### 2. ê²€ìƒ‰ ê²°ê³¼ ìºì‹±

```typescript
async getCachedSearch(
  query: string,
  filters?: SearchFilters
): Promise<SearchResult[] | null> {
  const key = this.generateCacheKey(query, filters);
  return this.get(key);
}

async cacheSearch(
  query: string,
  results: SearchResult[],
  filters?: SearchFilters,
  ttl: number = 300000 // 5ë¶„
): Promise<void> {
  const key = this.generateCacheKey(query, filters);
  this.set(key, results, ttl);
}

async invalidateSearchCache(query?: string): Promise<number> {
  if (query) {
    const pattern = new RegExp(`^search:${this.normalizeQuery(query)}:`, 'i');
    return this.invalidatePattern(pattern);
  } else {
    const pattern = /^search:/;
    return this.invalidatePattern(pattern);
  }
}
```

### 3. ì„ë² ë”© ìºì‹œ

```typescript
export class EmbeddingCacheService extends CacheService<number[]> {
  generateCacheKey(text: string): string {
    const normalized = text.toLowerCase().trim();
    return `embedding:${this.hashText(normalized)}`;
  }
  
  private hashText(text: string): string {
    // ê°„ë‹¨í•œ í•´ì‹œ í•¨ìˆ˜ (ì‹¤ì œë¡œëŠ” crypto.createHash ì‚¬ìš©)
    let hash = 0;
    for (let i = 0; i < text.length; i++) {
      const char = text.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 32ë¹„íŠ¸ ì •ìˆ˜ë¡œ ë³€í™˜
    }
    return Math.abs(hash).toString(36);
  }
  
  async getCachedEmbedding(text: string): Promise<number[] | null> {
    const key = this.generateCacheKey(text);
    return this.get(key);
  }
  
  async cacheEmbedding(text: string, embedding: number[], ttl: number = 3600000): Promise<void> {
    const key = this.generateCacheKey(text);
    this.set(key, embedding, ttl);
  }
}
```

## ğŸ“Š ìºì‹œ í†µê³„ ë° ëª¨ë‹ˆí„°ë§

### 1. í†µê³„ ìˆ˜ì§‘

```typescript
getStats(): CacheStats {
  const totalRequests = this.hits + this.misses;
  const hitRate = totalRequests > 0 ? this.hits / totalRequests : 0;
  
  let memoryUsage = 0;
  for (const entry of this.cache.values()) {
    memoryUsage += this.estimateMemoryUsage(entry);
  }
  
  return {
    hits: this.hits,
    misses: this.misses,
    totalRequests,
    hitRate,
    size: this.cache.size,
    memoryUsage
  };
}

private estimateMemoryUsage(entry: CacheEntry<T>): number {
  // ê°„ë‹¨í•œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¶”ì •
  let size = 0;
  
  // í‚¤ í¬ê¸° (ë¬¸ìì—´)
  size += entry.data.toString().length * 2; // UTF-16
  
  // ë©”íƒ€ë°ì´í„° í¬ê¸°
  size += 32; // timestamp, ttl, accessCount, lastAccessed
  
  return size;
}
```

### 2. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```typescript
class CacheMonitor {
  private cacheService: CacheService;
  private metrics: CacheMetrics[] = [];
  private monitoringInterval: NodeJS.Timeout | null = null;
  
  startMonitoring(interval: number = 60000): void {
    this.monitoringInterval = setInterval(() => {
      this.collectMetrics();
    }, interval);
  }
  
  private collectMetrics(): void {
    const stats = this.cacheService.getStats();
    const timestamp = new Date();
    
    this.metrics.push({
      timestamp,
      ...stats,
      memoryUsageMB: stats.memoryUsage / (1024 * 1024)
    });
    
    // ì˜¤ë˜ëœ ë©”íŠ¸ë¦­ ì œê±° (24ì‹œê°„)
    const cutoff = new Date(timestamp.getTime() - 24 * 60 * 60 * 1000);
    this.metrics = this.metrics.filter(m => m.timestamp > cutoff);
  }
  
  getMetrics(timeRange?: { start: Date; end: Date }): CacheMetrics[] {
    if (!timeRange) return this.metrics;
    
    return this.metrics.filter(m => 
      m.timestamp >= timeRange.start && m.timestamp <= timeRange.end
    );
  }
}
```

### 3. ìºì‹œ ìµœì í™”

```typescript
class CacheOptimizer {
  private cacheService: CacheService;
  
  constructor(cacheService: CacheService) {
    this.cacheService = cacheService;
  }
  
  optimize(): OptimizationResult {
    const stats = this.cacheService.getStats();
    const recommendations: string[] = [];
    
    // íˆíŠ¸ìœ¨ì´ ë‚®ìœ¼ë©´ TTL ì¡°ì •
    if (stats.hitRate < 0.5) {
      recommendations.push('Consider increasing TTL for better hit rate');
    }
    
    // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ë†’ìœ¼ë©´ í¬ê¸° ì¡°ì •
    if (stats.memoryUsage > 100 * 1024 * 1024) { // 100MB
      recommendations.push('Consider reducing cache size or implementing compression');
    }
    
    // ìºì‹œ í¬ê¸°ê°€ ì‘ìœ¼ë©´ í™•ì¥
    if (stats.size >= this.cacheService.maxSize * 0.9) {
      recommendations.push('Consider increasing cache size');
    }
    
    return {
      currentStats: stats,
      recommendations,
      estimatedImprovement: this.calculateImprovement(stats)
    };
  }
}
```

## ğŸ§ª ìºì‹œ í…ŒìŠ¤íŠ¸

### 1. ê¸°ë³¸ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸

```typescript
describe('CacheService', () => {
  let cache: CacheService<string>;
  
  beforeEach(() => {
    cache = new CacheService(10, 1000); // 10ê°œ í•­ëª©, 1ì´ˆ TTL
  });
  
  it('should store and retrieve data', () => {
    cache.set('key1', 'value1');
    expect(cache.get('key1')).toBe('value1');
  });
  
  it('should return null for non-existent key', () => {
    expect(cache.get('nonexistent')).toBeNull();
  });
  
  it('should respect TTL', async () => {
    cache.set('key1', 'value1', 100); // 100ms TTL
    expect(cache.get('key1')).toBe('value1');
    
    await new Promise(resolve => setTimeout(resolve, 150));
    expect(cache.get('key1')).toBeNull();
  });
  
  it('should implement LRU eviction', () => {
    // ìºì‹œ í¬ê¸°ë§Œí¼ ë°ì´í„° ì¶”ê°€
    for (let i = 0; i < 10; i++) {
      cache.set(`key${i}`, `value${i}`);
    }
    
    // ì²« ë²ˆì§¸ í•­ëª©ì— ì ‘ê·¼
    cache.get('key0');
    
    // ìƒˆ í•­ëª© ì¶”ê°€ (LRU ì œê±° ë°œìƒ)
    cache.set('key10', 'value10');
    
    // key0ì€ ì ‘ê·¼í–ˆìœ¼ë¯€ë¡œ ë‚¨ì•„ìˆì–´ì•¼ í•¨
    expect(cache.get('key0')).toBe('value0');
    // key1ì€ LRUë¡œ ì œê±°ë˜ì–´ì•¼ í•¨
    expect(cache.get('key1')).toBeNull();
  });
});
```

### 2. ì„±ëŠ¥ í…ŒìŠ¤íŠ¸

```typescript
describe('CacheService Performance', () => {
  it('should handle high throughput', () => {
    const cache = new CacheService(10000, 60000);
    const iterations = 100000;
    
    const startTime = Date.now();
    
    // ëŒ€ëŸ‰ ë°ì´í„° ì €ì¥
    for (let i = 0; i < iterations; i++) {
      cache.set(`key${i}`, `value${i}`);
    }
    
    // ëŒ€ëŸ‰ ë°ì´í„° ì¡°íšŒ
    for (let i = 0; i < iterations; i++) {
      cache.get(`key${i}`);
    }
    
    const endTime = Date.now();
    const duration = endTime - startTime;
    
    expect(duration).toBeLessThan(5000); // 5ì´ˆ ì´ë‚´
  });
});
```

## ğŸ“‹ ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê¸°ë³¸ ìºì‹œ ê¸°ëŠ¥
- [ ] LRU ìºì‹œ êµ¬í˜„
- [ ] TTL ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ìºì‹œ í†µê³„ ìˆ˜ì§‘ êµ¬í˜„
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¶”ì • êµ¬í˜„
- [ ] ìë™ ì •ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

### ê²€ìƒ‰ ìºì‹œ
- [ ] ê²€ìƒ‰ ê²°ê³¼ ìºì‹± êµ¬í˜„
- [ ] ì¿¼ë¦¬ ì •ê·œí™” êµ¬í˜„
- [ ] í•„í„° ì§ë ¬í™” êµ¬í˜„
- [ ] ìºì‹œ ë¬´íš¨í™” êµ¬í˜„
- [ ] ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì‘ì„±

### ì„ë² ë”© ìºì‹œ
- [ ] ì„ë² ë”© ìºì‹± êµ¬í˜„
- [ ] í…ìŠ¤íŠ¸ í•´ì‹± êµ¬í˜„
- [ ] ì„ë² ë”© ê²€ìƒ‰ ìµœì í™” êµ¬í˜„
- [ ] ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± ê°œì„ 
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„±

### ëª¨ë‹ˆí„°ë§ ë° ìµœì í™”
- [ ] ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ êµ¬í˜„
- [ ] ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ êµ¬í˜„
- [ ] ìµœì í™” ì¶”ì²œ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ëŒ€ì‹œë³´ë“œ ì—°ë™ êµ¬í˜„
- [ ] ë¶€í•˜ í…ŒìŠ¤íŠ¸ ì‘ì„±