---
globs: *.ts,*.js
description: ê¸°ì–µ ì•Œê³ ë¦¬ì¦˜ ë° ê²€ìƒ‰ ë­í‚¹ ìˆ˜ì‹ êµ¬í˜„ ê·œì¹™
---

# ê¸°ì–µ ì•Œê³ ë¦¬ì¦˜ ë° ê²€ìƒ‰ ë­í‚¹ ìˆ˜ì‹ ê·œì¹™

## ğŸ“Š ê²€ìƒ‰ ë­í‚¹ ê³µì‹ êµ¬í˜„

### ìµœì¢… ì ìˆ˜ ê³„ì‚°
```typescript
interface SearchScore {
  relevance: number;
  recency: number;
  importance: number;
  usage: number;
  duplication_penalty: number;
  final_score: number;
}

class SearchRanking {
  // ê¸°ë³¸ ê³„ìˆ˜ (M1 ì¶”ì²œê°’)
  private readonly ALPHA = 0.50;  // relevance
  private readonly BETA = 0.20;   // recency
  private readonly GAMMA = 0.20;  // importance
  private readonly DELTA = 0.10;  // usage
  private readonly EPSILON = 0.15; // duplication_penalty

  calculateFinalScore(score: Omit<SearchScore, 'final_score'>): number {
    return this.ALPHA * score.relevance +
           this.BETA * score.recency +
           this.GAMMA * score.importance +
           this.DELTA * score.usage -
           this.EPSILON * score.duplication_penalty;
  }
}
```

### ê´€ë ¨ì„±(relevance) ê³„ì‚°
```typescript
class RelevanceCalculator {
  // ê´€ë ¨ì„± ê°€ì¤‘ì¹˜ (M1 ì¶”ì²œê°’)
  private readonly WEIGHT_EMBEDDING = 0.60;
  private readonly WEIGHT_KEYWORD = 0.30;
  private readonly WEIGHT_TAG = 0.05;
  private readonly WEIGHT_TITLE = 0.05;

  calculateRelevance(
    embeddingSimilarity: number,
    bm25Score: number,
    tagMatch: number,
    titleHit: number
  ): number {
    return this.WEIGHT_EMBEDDING * embeddingSimilarity +
           this.WEIGHT_KEYWORD * this.normalizeBM25(bm25Score) +
           this.WEIGHT_TAG * tagMatch +
           this.WEIGHT_TITLE * titleHit;
  }

  // BM25 ì •ê·œí™”
  private normalizeBM25(bm25Score: number, kNorm: number = 2.0): number {
    return bm25Score / (bm25Score + kNorm);
  }

  // ì„ë² ë”© ìœ ì‚¬ë„ (ì½”ì‚¬ì¸)
  calculateEmbeddingSimilarity(queryEmbedding: number[], docEmbedding: number[]): number {
    const dotProduct = this.dotProduct(queryEmbedding, docEmbedding);
    const magnitudeA = this.magnitude(queryEmbedding);
    const magnitudeB = this.magnitude(docEmbedding);
    
    const cosine = dotProduct / (magnitudeA * magnitudeB);
    return Math.max(0, cosine); // ìŒìˆ˜ ë°©ì§€
  }

  // íƒœê·¸ ë§¤ì¹­ (ìì¹´ë“œ ìœ ì‚¬ë„)
  calculateTagMatch(queryTags: string[], docTags: string[]): number {
    const intersection = new Set(queryTags.filter(tag => docTags.includes(tag)));
    const union = new Set([...queryTags, ...docTags]);
    
    return intersection.size / union.size;
  }

  // íƒ€ì´í‹€ íˆíŠ¸
  calculateTitleHit(query: string, title: string): number {
    const queryLower = query.toLowerCase();
    const titleLower = title.toLowerCase();
    
    let score = 0;
    
    // ì •í™• ë§¤ì¹˜
    if (titleLower === queryLower) score += 1.0;
    // ì ‘ë‘ ë§¤ì¹˜
    else if (titleLower.startsWith(queryLower)) score += 0.5;
    // N-gram ë§¤ì¹˜
    else if (this.hasNgramMatch(queryLower, titleLower)) score += 0.2;
    
    return score;
  }
}
```

### ìµœê·¼ì„±(recency) ê³„ì‚°
```typescript
class RecencyCalculator {
  // ë°˜ê°ê¸° ì„¤ì • (ì¼ ë‹¨ìœ„)
  private readonly HALF_LIFE = {
    working: 2,
    episodic: 30,
    semantic: 180
  };

  calculateRecency(createdAt: Date, type: string): number {
    const ageDays = this.getAgeInDays(createdAt);
    const halfLife = this.HALF_LIFE[type as keyof typeof this.HALF_LIFE] || 30;
    
    return Math.exp(-Math.log(2) * ageDays / halfLife);
  }

  private getAgeInDays(date: Date): number {
    const now = new Date();
    const diffTime = now.getTime() - date.getTime();
    return diffTime / (1000 * 60 * 60 * 24);
  }
}
```

### ì¤‘ìš”ë„(importance) ê³„ì‚°
```typescript
class ImportanceCalculator {
  calculateImportance(
    userImportance: number,
    isPinned: boolean,
    type: string
  ): number {
    const pinnedBoost = isPinned ? 0.20 : 0;
    const typeBoost = this.getTypeBoost(type);
    
    return Math.max(0, Math.min(1, 
      userImportance + pinnedBoost + typeBoost
    ));
  }

  private getTypeBoost(type: string): number {
    switch (type) {
      case 'semantic': return 0.10;
      case 'episodic': return 0.00;
      case 'working': return -0.05;
      case 'procedural': return 0.05;
      default: return 0.00;
    }
  }
}
```

### ì‚¬ìš©ì„±(usage) ê³„ì‚°
```typescript
class UsageCalculator {
  calculateUsage(
    viewCount: number,
    citeCount: number,
    editCount: number,
    batchMin: number,
    batchMax: number
  ): number {
    const rawUsage = 
      Math.log(1 + viewCount) +
      2 * Math.log(1 + citeCount) +
      0.5 * Math.log(1 + editCount);
    
    return this.normalize(rawUsage, batchMin, batchMax);
  }

  private normalize(value: number, min: number, max: number, epsilon: number = 1e-6): number {
    return (value - min) / (max - min + epsilon);
  }
}
```

### ì¤‘ë³µ íŒ¨ë„í‹°(duplication_penalty) ê³„ì‚°
```typescript
class DuplicationPenaltyCalculator {
  calculateDuplicationPenalty(
    candidateEmbedding: number[],
    selectedEmbeddings: number[][]
  ): number {
    if (selectedEmbeddings.length === 0) return 0;
    
    let maxSimilarity = 0;
    
    for (const selectedEmbedding of selectedEmbeddings) {
      const similarity = this.cosineSimilarity(candidateEmbedding, selectedEmbedding);
      maxSimilarity = Math.max(maxSimilarity, similarity);
    }
    
    return maxSimilarity;
  }

  private cosineSimilarity(a: number[], b: number[]): number {
    const dotProduct = this.dotProduct(a, b);
    const magnitudeA = this.magnitude(a);
    const magnitudeB = this.magnitude(b);
    
    return dotProduct / (magnitudeA * magnitudeB);
  }
}
```

## ğŸ§  ë§ê° ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„

### ë§ê° ì ìˆ˜ ê³„ì‚°
```typescript
class ForgetScoreCalculator {
  // ë§ê° ì ìˆ˜ ê³„ìˆ˜ (M1 ì¶”ì²œê°’)
  private readonly U1 = 0.35; // recency ê°€ì¤‘ì¹˜
  private readonly U2 = 0.25; // usage ê°€ì¤‘ì¹˜
  private readonly U3 = 0.20; // duplication ê°€ì¤‘ì¹˜
  private readonly U4 = 0.15; // importance ê°€ì¤‘ì¹˜
  private readonly U5 = 0.30; // pinned ê°€ì¤‘ì¹˜

  calculateForgetScore(
    recency: number,
    usage: number,
    dupRatio: number,
    importance: number,
    isPinned: boolean
  ): number {
    return this.U1 * (1 - recency) +
           this.U2 * (1 - usage) +
           this.U3 * dupRatio -
           this.U4 * importance -
           this.U5 * (isPinned ? 1 : 0);
  }
}
```

### ë§ê° ì •ì±… ì ìš©
```typescript
class ForgetPolicy {
  // TTL ì„¤ì • (ì¼ ë‹¨ìœ„)
  private readonly TTL_SOFT = {
    working: 2,
    episodic: 30,
    semantic: Infinity
  };
  
  private readonly TTL_HARD = {
    working: 7,
    episodic: 180,
    semantic: Infinity
  };

  // ì†Œí”„íŠ¸ ì‚­ì œ í›„ë³´ ì„ ì •
  isSoftDeleteCandidate(
    memory: MemoryItem,
    forgetScore: number
  ): boolean {
    const ageDays = this.getAgeInDays(memory.created_at);
    const ttl = this.TTL_SOFT[memory.type as keyof typeof this.TTL_SOFT];
    
    return forgetScore >= 0.6 && 
           ageDays >= ttl && 
           !memory.pinned;
  }

  // í•˜ë“œ ì‚­ì œ í›„ë³´ ì„ ì •
  isHardDeleteCandidate(
    memory: MemoryItem,
    forgetScore: number
  ): boolean {
    const ageDays = this.getAgeInDays(memory.created_at);
    const ttl = this.TTL_HARD[memory.type as keyof typeof this.TTL_HARD];
    
    return forgetScore >= 0.8 && 
           ageDays >= ttl && 
           !memory.pinned;
  }
}
```

## ğŸ”„ ê°„ê²© ë°˜ë³µ ì•Œê³ ë¦¬ì¦˜

### ê°„ê²© ë°˜ë³µ ìŠ¤ì¼€ì¤„ëŸ¬
```typescript
class SpacedReviewScheduler {
  // ê°„ê²© ë°˜ë³µ ê³„ìˆ˜
  private readonly A1 = 0.6; // importance ê°€ì¤‘ì¹˜
  private readonly A2 = 0.4; // usage ê°€ì¤‘ì¹˜
  private readonly A3 = 0.5; // helpful feedback ê°€ì¤‘ì¹˜
  private readonly A4 = 0.7; // bad feedback ê°€ì¤‘ì¹˜

  calculateNextReviewInterval(
    currentInterval: number,
    importance: number,
    usage: number,
    helpfulFeedback: number,
    badFeedback: number
  ): number {
    const multiplier = 1 + 
      this.A1 * importance +
      this.A2 * usage +
      this.A3 * helpfulFeedback -
      this.A4 * badFeedback;
    
    return Math.ceil(currentInterval * multiplier);
  }

  // ë¦¬ë·° í™•ë¥  ê³„ì‚°
  calculateRecallProbability(
    timeSinceLastReview: number,
    interval: number
  ): number {
    return Math.exp(-timeSinceLastReview / interval);
  }

  // ë¦¬ë·° í•„ìš” ì—¬ë¶€ íŒë‹¨
  needsReview(
    timeSinceLastReview: number,
    interval: number,
    threshold: number = 0.7
  ): boolean {
    const recallProb = this.calculateRecallProbability(timeSinceLastReview, interval);
    return recallProb <= threshold;
  }
}
```

## ğŸ” 2ë‹¨ê³„ ê²€ìƒ‰ íŒŒì´í”„ë¼ì¸

### ê²€ìƒ‰ íŒŒì´í”„ë¼ì¸ êµ¬í˜„
```typescript
class SearchPipeline {
  constructor(
    private vectorSearch: VectorSearchService,
    private textSearch: TextSearchService,
    private rankingCalculator: SearchRanking
  ) {}

  async search(
    query: string,
    filters: SearchFilters,
    limit: number = 10
  ): Promise<SearchResult[]> {
    // 1. í›„ë³´ ìƒì„±
    const candidates = await this.generateCandidates(query, filters);
    
    // 2. íŠ¹ì§• ê³„ì‚°
    const features = await this.computeFeatures(candidates, query);
    
    // 3. ì ìˆ˜ ê³„ì‚°
    const scoredResults = this.calculateScores(candidates, features);
    
    // 4. ë‹¤ì–‘í™” (MMR)
    const diversifiedResults = this.diversifyResults(scoredResults, limit);
    
    // 5. ì„ê³„ê°’ í•„í„°ë§
    return this.filterByThreshold(diversifiedResults, 0.35);
  }

  private async generateCandidates(
    query: string,
    filters: SearchFilters
  ): Promise<MemoryItem[]> {
    // ë²¡í„° ê²€ìƒ‰ (ANN)
    const vectorResults = await this.vectorSearch.search(query, 50);
    
    // í…ìŠ¤íŠ¸ ê²€ìƒ‰ (BM25)
    const textResults = await this.textSearch.search(query, 50);
    
    // í•©ì§‘í•© ìƒì„±
    const candidateMap = new Map<string, MemoryItem>();
    
    vectorResults.forEach(item => candidateMap.set(item.id, item));
    textResults.forEach(item => candidateMap.set(item.id, item));
    
    return Array.from(candidateMap.values());
  }

  private async computeFeatures(
    candidates: MemoryItem[],
    query: string
  ): Promise<FeatureVector[]> {
    // ê° í›„ë³´ì— ëŒ€í•´ íŠ¹ì§• ê³„ì‚°
    return Promise.all(candidates.map(async (candidate) => {
      const relevance = await this.calculateRelevance(candidate, query);
      const recency = this.calculateRecency(candidate.created_at, candidate.type);
      const importance = this.calculateImportance(candidate);
      const usage = await this.calculateUsage(candidate.id);
      
      return {
        memory_id: candidate.id,
        relevance,
        recency,
        importance,
        usage,
        duplication_penalty: 0 // ì´ˆê¸°ê°’
      };
    }));
  }
}
```

## ğŸ“ˆ ì„±ëŠ¥ ìµœì í™”

### ë°°ì¹˜ ì •ê·œí™”
```typescript
class BatchNormalizer {
  normalizeFeatures(features: FeatureVector[]): FeatureVector[] {
    const normalized = [...features];
    
    // usage ì •ê·œí™”
    const usageValues = features.map(f => f.usage);
    const usageMin = Math.min(...usageValues);
    const usageMax = Math.max(...usageValues);
    
    normalized.forEach(feature => {
      feature.usage = this.normalize(feature.usage, usageMin, usageMax);
    });
    
    return normalized;
  }

  private normalize(value: number, min: number, max: number): number {
    return (value - min) / (max - min + 1e-6);
  }
}
```

### MMR ë‹¤ì–‘í™”
```typescript
class MMRDiversifier {
  diversify(
    results: ScoredResult[],
    limit: number,
    lambda: number = 0.8
  ): ScoredResult[] {
    const selected: ScoredResult[] = [];
    const remaining = [...results];
    
    while (selected.length < limit && remaining.length > 0) {
      let bestIndex = 0;
      let bestScore = -Infinity;
      
      remaining.forEach((candidate, index) => {
        const mmrScore = this.calculateMMRScore(
          candidate,
          selected,
          lambda
        );
        
        if (mmrScore > bestScore) {
          bestScore = mmrScore;
          bestIndex = index;
        }
      });
      
      selected.push(remaining[bestIndex]);
      remaining.splice(bestIndex, 1);
    }
    
    return selected;
  }

  private calculateMMRScore(
    candidate: ScoredResult,
    selected: ScoredResult[],
    lambda: number
  ): number {
    const relevanceScore = candidate.final_score;
    const maxSimilarity = this.getMaxSimilarity(candidate, selected);
    
    return lambda * relevanceScore - (1 - lambda) * maxSimilarity;
  }
}
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ê°€ì´ë“œ

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì˜ˆì‹œ
```typescript
describe('SearchRanking', () => {
  let ranking: SearchRanking;
  
  beforeEach(() => {
    ranking = new SearchRanking();
  });
  
  it('should calculate final score correctly', () => {
    const score = {
      relevance: 0.8,
      recency: 0.6,
      importance: 0.7,
      usage: 0.5,
      duplication_penalty: 0.2
    };
    
    const result = ranking.calculateFinalScore(score);
    expect(result).toBeCloseTo(0.8 * 0.5 + 0.6 * 0.2 + 0.7 * 0.2 + 0.5 * 0.1 - 0.2 * 0.15);
  });
});
```
 
 