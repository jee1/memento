---
globs: "src/services/performance-monitor.ts,src/test/performance-benchmark.ts,src/test-performance-monitoring.ts"
description: ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë° ë²¤ì¹˜ë§ˆí¬ ê°œë°œ ê·œì¹™
---

# ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë° ë²¤ì¹˜ë§ˆí¬ ê°œë°œ ê·œì¹™

## ğŸ“‹ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

### í˜„ì¬ êµ¬í˜„ ìƒíƒœ
- **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**: `src/services/performance-monitor.ts` (367ì¤„)
- **ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬**: `src/test/performance-benchmark.ts` (497ì¤„)
- **ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸**: `src/test-performance-monitoring.ts` (172ì¤„)

### í•µì‹¬ ì¸í„°í˜ì´ìŠ¤

```typescript
interface PerformanceMetrics {
  database: {
    totalMemories: number;
    memoryByType: Record<string, number>;
    averageMemorySize: number;
    databaseSize: number;
    indexUsage: Record<string, number>;
    queryPerformance: {
      averageQueryTime: number;
      slowQueries: Array<{ query: string; time: number; count: number }>;
    };
  };
  search: {
    totalSearches: number;
    averageSearchTime: number;
    searchByType: Record<string, number>;
    cacheHitRate: number;
    embeddingSearchRate: number;
  };
  memory: {
    usage: number;
    heapUsed: number;
    heapTotal: number;
    external: number;
    rss: number;
  };
  system: {
    uptime: number;
    cpuUsage: number;
    loadAverage: number[];
    diskUsage: number;
  };
}
```

## ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤

### 1. ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```typescript
export class PerformanceMonitor {
  private metrics: PerformanceMetrics;
  private collectionInterval: number = 5000; // 5ì´ˆ
  private intervalId: NodeJS.Timeout | null = null;
  private db: sqlite3.Database;
  
  constructor(db: sqlite3.Database) {
    this.db = db;
    this.metrics = this.initializeMetrics();
  }
  
  startMonitoring(): void {
    if (this.intervalId) return;
    
    this.intervalId = setInterval(() => {
      this.collectMetrics();
    }, this.collectionInterval);
  }
  
  private async collectMetrics(): Promise<void> {
    try {
      // ë°ì´í„°ë² ì´ìŠ¤ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
      this.metrics.database = await this.collectDatabaseMetrics();
      
      // ê²€ìƒ‰ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
      this.metrics.search = await this.collectSearchMetrics();
      
      // ë©”ëª¨ë¦¬ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
      this.metrics.memory = await this.collectMemoryMetrics();
      
      // ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
      this.metrics.system = await this.collectSystemMetrics();
      
      // ì„ê³„ê°’ í™•ì¸
      this.checkThresholds();
    } catch (error) {
      console.error('Failed to collect metrics:', error);
    }
  }
}
```

### 2. ë°ì´í„°ë² ì´ìŠ¤ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```typescript
private async collectDatabaseMetrics(): Promise<DatabaseMetrics> {
  const totalMemories = await this.getTotalMemories();
  const memoryByType = await this.getMemoryByType();
  const averageMemorySize = await this.getAverageMemorySize();
  const databaseSize = await this.getDatabaseSize();
  const indexUsage = await this.getIndexUsage();
  const queryPerformance = await this.getQueryPerformance();
  
  return {
    totalMemories,
    memoryByType,
    averageMemorySize,
    databaseSize,
    indexUsage,
    queryPerformance
  };
}

private async getTotalMemories(): Promise<number> {
  const result = await this.db.get('SELECT COUNT(*) as count FROM memory_item');
  return result.count;
}

private async getMemoryByType(): Promise<Record<string, number>> {
  const result = await this.db.all(`
    SELECT type, COUNT(*) as count 
    FROM memory_item 
    GROUP BY type
  `);
  
  return result.reduce((acc, row) => {
    acc[row.type] = row.count;
    return acc;
  }, {} as Record<string, number>);
}
```

### 3. ê²€ìƒ‰ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```typescript
private async collectSearchMetrics(): Promise<SearchMetrics> {
  const totalSearches = await this.getTotalSearches();
  const averageSearchTime = await this.getAverageSearchTime();
  const searchByType = await this.getSearchByType();
  const cacheHitRate = await this.getCacheHitRate();
  const embeddingSearchRate = await this.getEmbeddingSearchRate();
  
  return {
    totalSearches,
    averageSearchTime,
    searchByType,
    cacheHitRate,
    embeddingSearchRate
  };
}

private async getTotalSearches(): Promise<number> {
  const result = await this.db.get(`
    SELECT COUNT(*) as count 
    FROM search_log 
    WHERE created_at > datetime('now', '-24 hours')
  `);
  return result.count;
}
```

### 4. ë©”ëª¨ë¦¬ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```typescript
private async collectMemoryMetrics(): Promise<MemoryMetrics> {
  const usage = process.memoryUsage();
  
  return {
    usage: usage.heapUsed / usage.heapTotal,
    heapUsed: usage.heapUsed,
    heapTotal: usage.heapTotal,
    external: usage.external,
    rss: usage.rss
  };
}
```

### 5. ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```typescript
private async collectSystemMetrics(): Promise<SystemMetrics> {
  const uptime = process.uptime();
  const cpuUsage = await this.getCpuUsage();
  const loadAverage = await this.getLoadAverage();
  const diskUsage = await this.getDiskUsage();
  
  return {
    uptime,
    cpuUsage,
    loadAverage,
    diskUsage
  };
}

private async getCpuUsage(): Promise<number> {
  const startUsage = process.cpuUsage();
  await new Promise(resolve => setTimeout(resolve, 100));
  const endUsage = process.cpuUsage(startUsage);
  
  const totalUsage = endUsage.user + endUsage.system;
  const totalTime = 100000; // 100ms in microseconds
  return totalUsage / totalTime;
}
```

## ğŸš¨ ì„ê³„ê°’ ëª¨ë‹ˆí„°ë§

### 1. ì„ê³„ê°’ ì„¤ì •

```typescript
interface PerformanceThresholds {
  maxResponseTime: number;
  maxMemoryUsage: number;
  minCacheHitRate: number;
  maxErrorRate: number;
  maxCpuUsage: number;
  maxDiskUsage: number;
}

class PerformanceMonitor {
  private thresholds: PerformanceThresholds = {
    maxResponseTime: 1000,      // 1ì´ˆ
    maxMemoryUsage: 0.8,        // 80%
    minCacheHitRate: 0.7,       // 70%
    maxErrorRate: 0.05,         // 5%
    maxCpuUsage: 0.8,           // 80%
    maxDiskUsage: 0.9           // 90%
  };
  
  setThresholds(thresholds: Partial<PerformanceThresholds>): void {
    this.thresholds = { ...this.thresholds, ...thresholds };
  }
}
```

### 2. ì„ê³„ê°’ í™•ì¸ ë° ì•Œë¦¼

```typescript
private checkThresholds(): void {
  const alerts: Alert[] = [];
  
  // ì‘ë‹µ ì‹œê°„ í™•ì¸
  if (this.metrics.search.averageSearchTime > this.thresholds.maxResponseTime) {
    alerts.push({
      type: 'performance',
      severity: 'warning',
      message: `Search response time exceeded threshold: ${this.metrics.search.averageSearchTime}ms`,
      timestamp: new Date(),
      value: this.metrics.search.averageSearchTime,
      threshold: this.thresholds.maxResponseTime
    });
  }
  
  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸
  if (this.metrics.memory.usage > this.thresholds.maxMemoryUsage) {
    alerts.push({
      type: 'memory',
      severity: 'critical',
      message: `Memory usage exceeded threshold: ${(this.metrics.memory.usage * 100).toFixed(1)}%`,
      timestamp: new Date(),
      value: this.metrics.memory.usage,
      threshold: this.thresholds.maxMemoryUsage
    });
  }
  
  // ìºì‹œ íˆíŠ¸ìœ¨ í™•ì¸
  if (this.metrics.search.cacheHitRate < this.thresholds.minCacheHitRate) {
    alerts.push({
      type: 'cache',
      severity: 'warning',
      message: `Cache hit rate below threshold: ${(this.metrics.search.cacheHitRate * 100).toFixed(1)}%`,
      timestamp: new Date(),
      value: this.metrics.search.cacheHitRate,
      threshold: this.thresholds.minCacheHitRate
    });
  }
  
  // ì•Œë¦¼ ì²˜ë¦¬
  if (alerts.length > 0) {
    this.handleAlerts(alerts);
  }
}
```

### 3. ì•Œë¦¼ ì²˜ë¦¬

```typescript
private handleAlerts(alerts: Alert[]): void {
  for (const alert of alerts) {
    // ë¡œê·¸ ì¶œë ¥
    console.log(`[${alert.severity.toUpperCase()}] ${alert.message}`);
    
    // ì‹¬ê°í•œ ì•Œë¦¼ì€ ì¦‰ì‹œ ì²˜ë¦¬
    if (alert.severity === 'critical') {
      this.handleCriticalAlert(alert);
    }
    
    // ì•Œë¦¼ íˆìŠ¤í† ë¦¬ ì €ì¥
    this.saveAlert(alert);
  }
}

private handleCriticalAlert(alert: Alert): void {
  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ë©´ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰
  if (alert.type === 'memory') {
    if (global.gc) {
      global.gc();
    }
  }
  
  // ì¶”ê°€ì ì¸ ë³µêµ¬ ì‘ì—… ìˆ˜í–‰
  this.performRecoveryActions(alert);
}
```

## ğŸ“ˆ ì„±ëŠ¥ ë¦¬í¬íŠ¸ ìƒì„±

### 1. ë¦¬í¬íŠ¸ ìƒì„±

```typescript
async generateReport(timeRange: string = '24h'): Promise<PerformanceReport> {
  const startTime = this.getTimeRangeStart(timeRange);
  const endTime = new Date();
  
  const report: PerformanceReport = {
    timeRange: { start: startTime, end: endTime },
    summary: {
      totalRequests: this.metrics.search.totalSearches,
      averageResponseTime: this.metrics.search.averageSearchTime,
      cacheHitRate: this.metrics.search.cacheHitRate,
      errorRate: this.calculateErrorRate(),
      memoryUsage: this.metrics.memory.usage,
      uptime: this.metrics.system.uptime
    },
    trends: await this.analyzeTrends(startTime, endTime),
    recommendations: await this.generateRecommendations(),
    alerts: this.getRecentAlerts(startTime, endTime)
  };
  
  return report;
}
```

### 2. íŠ¸ë Œë“œ ë¶„ì„

```typescript
private async analyzeTrends(startTime: Date, endTime: Date): Promise<TrendAnalysis> {
  const metrics = await this.getHistoricalMetrics(startTime, endTime);
  
  return {
    responseTime: this.calculateTrend(metrics, 'averageSearchTime'),
    memoryUsage: this.calculateTrend(metrics, 'memoryUsage'),
    cacheHitRate: this.calculateTrend(metrics, 'cacheHitRate'),
    throughput: this.calculateTrend(metrics, 'totalSearches')
  };
}

private calculateTrend(metrics: any[], field: string): TrendDirection {
  if (metrics.length < 2) return 'stable';
  
  const values = metrics.map(m => m[field]);
  const firstHalf = values.slice(0, Math.floor(values.length / 2));
  const secondHalf = values.slice(Math.floor(values.length / 2));
  
  const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
  const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
  
  const change = (secondAvg - firstAvg) / firstAvg;
  
  if (Math.abs(change) < 0.05) return 'stable';
  return change > 0 ? 'increasing' : 'decreasing';
}
```

### 3. ìµœì í™” ì¶”ì²œ

```typescript
private async generateRecommendations(): Promise<OptimizationRecommendation[]> {
  const recommendations: OptimizationRecommendation[] = [];
  
  // ì‘ë‹µ ì‹œê°„ì´ ëŠë¦° ê²½ìš°
  if (this.metrics.search.averageSearchTime > 500) {
    recommendations.push({
      type: 'performance',
      priority: 'high',
      title: 'Optimize search performance',
      description: 'Average search time is above 500ms. Consider optimizing queries or adding indexes.',
      actions: [
        'Review slow queries in query performance metrics',
        'Add missing database indexes',
        'Consider implementing query caching'
      ]
    });
  }
  
  // ìºì‹œ íˆíŠ¸ìœ¨ì´ ë‚®ì€ ê²½ìš°
  if (this.metrics.search.cacheHitRate < 0.5) {
    recommendations.push({
      type: 'cache',
      priority: 'medium',
      title: 'Improve cache hit rate',
      description: 'Cache hit rate is below 50%. Consider adjusting cache TTL or size.',
      actions: [
        'Increase cache TTL for frequently accessed data',
        'Review cache invalidation strategy',
        'Consider increasing cache size'
      ]
    });
  }
  
  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ë†’ì€ ê²½ìš°
  if (this.metrics.memory.usage > 0.7) {
    recommendations.push({
      type: 'memory',
      priority: 'high',
      title: 'Optimize memory usage',
      description: 'Memory usage is above 70%. Consider optimizing data structures or implementing cleanup.',
      actions: [
        'Review memory-intensive operations',
        'Implement periodic cleanup routines',
        'Consider data compression or archiving'
      ]
    });
  }
  
  return recommendations;
}
```

## ğŸ§ª ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬

### 1. ë²¤ì¹˜ë§ˆí¬ í´ë˜ìŠ¤

```typescript
export class PerformanceBenchmark {
  private client: any;
  private performanceMonitor: PerformanceMonitor | null = null;
  private results: BenchmarkResult[] = [];
  
  constructor(client: any) {
    this.client = client;
  }
  
  async runComprehensiveBenchmark(): Promise<BenchmarkResult[]> {
    console.log('ğŸš€ Starting comprehensive performance benchmark...');
    
    const results: BenchmarkResult[] = [];
    
    // 1. ë©”ëª¨ë¦¬ ì €ì¥ ë²¤ì¹˜ë§ˆí¬
    results.push(await this.benchmarkMemoryStorage());
    
    // 2. ê²€ìƒ‰ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
    results.push(await this.benchmarkSearchPerformance());
    
    // 3. ìºì‹œ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
    results.push(await this.benchmarkCachePerformance());
    
    // 4. ë™ì‹œì„± ë²¤ì¹˜ë§ˆí¬
    results.push(await this.benchmarkConcurrency());
    
    // 5. ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë²¤ì¹˜ë§ˆí¬
    results.push(await this.benchmarkMemoryUsage());
    
    this.results = results;
    return results;
  }
}
```

### 2. ë©”ëª¨ë¦¬ ì €ì¥ ë²¤ì¹˜ë§ˆí¬

```typescript
private async benchmarkMemoryStorage(): Promise<BenchmarkResult> {
  const testName = 'Memory Storage';
  const iterations = 1000;
  const times: number[] = [];
  const errors: string[] = [];
  
  console.log(`ğŸ“ Running ${testName} benchmark (${iterations} iterations)...`);
  
  const memoryBefore = process.memoryUsage();
  
  for (let i = 0; i < iterations; i++) {
    try {
      const startTime = Date.now();
      
      await this.client.remember({
        content: `Benchmark memory ${i}: Testing memory storage performance`,
        type: 'episodic',
        tags: ['benchmark', 'storage'],
        importance: 0.5
      });
      
      const endTime = Date.now();
      times.push(endTime - startTime);
    } catch (error) {
      errors.push(`Iteration ${i}: ${error.message}`);
    }
  }
  
  const memoryAfter = process.memoryUsage();
  
  return this.calculateBenchmarkResult(
    testName,
    iterations,
    times,
    errors,
    memoryBefore,
    memoryAfter
  );
}
```

### 3. ê²€ìƒ‰ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬

```typescript
private async benchmarkSearchPerformance(): Promise<BenchmarkResult> {
  const testName = 'Search Performance';
  const iterations = 500;
  const times: number[] = [];
  const errors: string[] = [];
  
  console.log(`ğŸ” Running ${testName} benchmark (${iterations} iterations)...`);
  
  const memoryBefore = process.memoryUsage();
  
  for (let i = 0; i < iterations; i++) {
    try {
      const startTime = Date.now();
      
      await this.client.recall({
        query: `benchmark search ${i}`,
        limit: 10
      });
      
      const endTime = Date.now();
      times.push(endTime - startTime);
    } catch (error) {
      errors.push(`Iteration ${i}: ${error.message}`);
    }
  }
  
  const memoryAfter = process.memoryUsage();
  
  return this.calculateBenchmarkResult(
    testName,
    iterations,
    times,
    errors,
    memoryBefore,
    memoryAfter
  );
}
```

### 4. ë™ì‹œì„± ë²¤ì¹˜ë§ˆí¬

```typescript
private async benchmarkConcurrency(): Promise<BenchmarkResult> {
  const testName = 'Concurrency';
  const concurrentUsers = 10;
  const requestsPerUser = 50;
  const times: number[] = [];
  const errors: string[] = [];
  
  console.log(`ğŸ‘¥ Running ${testName} benchmark (${concurrentUsers} users, ${requestsPerUser} requests each)...`);
  
  const memoryBefore = process.memoryUsage();
  const startTime = Date.now();
  
  const userPromises = Array.from({ length: concurrentUsers }, (_, userIndex) =>
    this.simulateUser(userIndex, requestsPerUser, times, errors)
  );
  
  await Promise.all(userPromises);
  
  const endTime = Date.now();
  const memoryAfter = process.memoryUsage();
  
  return this.calculateBenchmarkResult(
    testName,
    concurrentUsers * requestsPerUser,
    times,
    errors,
    memoryBefore,
    memoryAfter
  );
}
```

## ğŸ“‹ ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
- [ ] ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì„ê³„ê°’ ëª¨ë‹ˆí„°ë§ êµ¬í˜„
- [ ] ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì„±ëŠ¥ ë¦¬í¬íŠ¸ ìƒì„± êµ¬í˜„
- [ ] íŠ¸ë Œë“œ ë¶„ì„ êµ¬í˜„
- [ ] ìµœì í™” ì¶”ì²œ ì‹œìŠ¤í…œ êµ¬í˜„

### ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
- [ ] ì¢…í•© ë²¤ì¹˜ë§ˆí¬ êµ¬í˜„
- [ ] ë©”ëª¨ë¦¬ ì €ì¥ ë²¤ì¹˜ë§ˆí¬ êµ¬í˜„
- [ ] ê²€ìƒ‰ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ êµ¬í˜„
- [ ] ìºì‹œ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ êµ¬í˜„
- [ ] ë™ì‹œì„± ë²¤ì¹˜ë§ˆí¬ êµ¬í˜„
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë²¤ì¹˜ë§ˆí¬ êµ¬í˜„

### ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸
- [ ] ëª¨ë‹ˆí„°ë§ ë„êµ¬ í…ŒìŠ¤íŠ¸ êµ¬í˜„
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ êµ¬í˜„
- [ ] ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸ êµ¬í˜„
- [ ] ì„±ëŠ¥ ì„ê³„ê°’ í…ŒìŠ¤íŠ¸ êµ¬í˜„
- [ ] ì•Œë¦¼ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ êµ¬í˜„
- [ ] ë¦¬í¬íŠ¸ ìƒì„± í…ŒìŠ¤íŠ¸ êµ¬í˜„